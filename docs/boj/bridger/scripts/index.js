/* Copyright 2025 Steve Butler (henspace.com)
 * License: MIT
 */
const LOGGER = new hcjeLib.errors.Logger(20);const STORAGE_KEY_PREFIX = 'BridgeOverJupiter';const CLICKS_PER_S = 6;const MAX_CLICKS_PER_S = 8;const GAME_WIDTH = 672;const GAME_HEIGHT = 420;const DROP_VY = 20;const DROP_AY = 100;const SCAFFOLD_SPEED_X = 2500;const ENTRY_SPEED = 100;const MIN_EXIT_SPEED = 100;const SPACESHIP_SPEED_X = 360;const BRIDGE_SAFE_IN = 2;const BRIDGE_SAFE_OUT = 1;const FALL_SFX_KEY = 'FALL';const FALL_SFX_DEFINITION = {title: FALL_SFX_KEY,bpm: 120,fadeSeconds: 0.1,tracks:[{instrument: {adsr: [0.01, 0.25, 0.7, 0.5],allowMerge: false,maxGain: 1,sustainTime: 0.1,sweepFactor: 0.2,waveform: 'sine',},notes: 'C',octave: 5},]};const ROCKET_SFX_KEY = 'ROCKET';const ROCKET_SFX_DEFINITION = {title: ROCKET_SFX_KEY,bpm: 60,fadeSeconds: 0.1,tracks:[{instrument: {adsr: [0.01, 0, 1, 0.1],allowMerge: true,maxGain: 1,sustainTime: 1,sweepFactor: 1,waveform: 'noise',},notes: 'EE',octave: 2},]};const SYNTH_DEFINITION = {bpm: 190,fadeSeconds: 0.1,loop: true,tracks:[{instrument: hcjeLib.audio.Instrument.PIANO,notes: 'C C8Eb8 D8-Bb8|Eb8F8 Eb D|C8D8 C -Bb|-G2 -G8-Bb8||C C8Eb8 D8-Bb8|Eb8F8 G G|G8F8 Eb F|Eb2 Bb8G8||F F Eb8G8|F -Bb Bb8G8|F F G8Bb8|+C2 +C8+D8||+Eb +D +C|Bb +Eb G|F8Eb8 FG |Bb2 -G8-Bb8|',octave: 4},{instrument: {adsr: [0.1, 0.25, 0.5, 0.1],allowMerge: false,maxGain: 0.5,sustainTime: 0.1,sweepFactor: 1,waveform: 'sine',},notes: 'Ab ~     Bb   |G     ~  G|Ab   ~  Bb|+C2  Bb    ||Ab ~     Bb   |G     ~ Eb8G8|Ab   ~ +C|~ +Eb G    ||Bb ~ +C    |+D  ~  G    |Bb ~ +Eb   |+Ab +G +F    ||++C  +Bb +Ab|+G  +F +Eb|+Ab    +F +Eb|+D +C Bb    | ',octave: 2},{instrument: hcjeLib.audio.Instrument.SNARE,notes: '~G~',octave: 6},{instrument: hcjeLib.audio.Instrument.DRUM,notes: 'C ~ ~ C C ~',octave: 2},]};function formSpriteName(spriteName) {return spriteName.replace('sprites', 'sprites_retro');}function formBackgroundName(backgroundName) {return backgroundName.replace(/\.(png|jpg)/, '-retro.$1');}function createTextureManager(gameArea, textureDataUrl, textureUrl) {return hcjeLib.sprites.loadSpriteSheet(textureDataUrl, textureUrl,new hcjeLib.domTools.TimeLimitedBusyIndicator({label:'loading',timeoutS: 15,timeoutMessage: 'Failed to load sprite sheet in time. Click OK to keep waiting.'})).then((textureManager) => {textureManager.spriteFactory = new hcjeLib.sprites.DomImageSpriteFactory(gameArea);return textureManager;});}function createSpaceship(textureManager) {const sprite = textureManager.createSprite(formSpriteName('sprites_spaceship.png'), [{name:'fly', interval: 100,cycleType: hcjeLib.sprites.CycleType.OSCILLATE}]);sprite.renderer.classList.add('bridger-spaceship');sprite.dynamics = new hcjeLib.sprites.Dynamics();return sprite;}function createWalker(textureManager, lastWalker) {const sprite = textureManager.createSprite(formSpriteName(`sprites_spaceman${lastWalker ? '_last' : ''}.png`), [{name:'walk', interval:(dynamics) => hcjeLib.sprites.Sprite.deriveWalk(dynamics, 2)},{name:'fall', interval: 100,cycleType: hcjeLib.sprites.CycleType.OSCILLATE}]);sprite.renderer.classList.add('bridger-walker');sprite.dynamics = new hcjeLib.sprites.Dynamics();return sprite;}function createRock(textureManager) {const sprite = textureManager.createSprite(formSpriteName('sprites_rock.png'));sprite.dynamics = new hcjeLib.sprites.Dynamics();return sprite;}function createScaffold(textureManager) {const sprite = textureManager.createSprite(formSpriteName('sprites_scaffold.png'));sprite.dynamics = new hcjeLib.sprites.Dynamics();return sprite;}function createBridge(animator, gameArea, textureManager) {const gameDims = gameArea.designDims;const floorLevel = Math.floor(gameDims.height / 3);const bridge = [];let rock = createRock(textureManager);bridge.push(rock);animator.addTarget(rock);const rockDims = bridge[0].dimensions;const rockCount = Math.ceil(gameDims.width / rockDims.width);for (let rockIndex = 0; rockIndex < rockCount; rockIndex++) {if (rockIndex > 0) {rock = createRock(textureManager);bridge.push(rock);animator.addTarget(rock);}bridge[rockIndex].position = {x: rockIndex * rockDims.width, y: -rockDims.height};}const promises = [];const randomBridge = hcjeLib.utils.shuffle([...bridge]);let delay = 0;for (const rock of hcjeLib.utils.shuffle([...bridge])) {promises.push(new Promise((resolve) => {setTimeout(() => {rock.dynamics.vy = DROP_VY;rock.dynamics.ay = DROP_AY;const adjuster = new hcjeLib.sprites.ReachTargetXY(rock, rock.position.x, floorLevel);adjuster.onCompletion = (reason) => resolve();rock.adjuster = adjuster;}, delay);}));delay += 100;}animator.active = true;return Promise.all(promises).then(() => {animator.active = false;return bridge;});}function breakBridge(config) {const promises = []const gaps = config.gaps || 2;const safeIn = config.safeIn || 2;const safeOut = config.safeOut || 1;let minLand = config.minLand ?? 0;let maxLand = config.maxLand ?? 3;let minBreakSpan = config.minBreakSpan || 2;const breakable = config.bridge.length - safeIn - safeOut;const maxPossibleLand = Math.floor((breakable - gaps) / (gaps - 1));minLand = Math.min(minLand, maxPossibleLand); // min space required for the gaps.maxLand = Math.min(maxLand, maxPossibleLand); // max space required for the gaps.const maxSpread = gaps + (gaps - 1) * maxLand;let gapIndex = 0;const breakPattern = [];for (let n = 0; n < gaps; n++) {breakPattern.push(gapIndex);const land = hcjeLib.utils.getRandomIntInclusive(minLand, maxLand);gapIndex += land + 1;if (land === maxLand) {maxLand--;}}let breakSpan = breakPattern[breakPattern.length - 1] - breakPattern[0];if (breakSpan < minBreakSpan) {console.debug(`Break span < ${minBreakSpan} so add extra gap.`);breakPattern.push(breakPattern[0] + minBreakSpan);breakSpan = minBreakSpan;}const maxOffset = breakable - breakSpan;const offset = maxOffset <= 0 ? 0 : hcjeLib.utils.getRandomIntExclusive(0, maxOffset);LOGGER.debug(`Land ${minLand} to ${maxLand}: pattern ${breakPattern.join(',')}`);const gapIndexes = [];for (let gap = 0; gap < breakPattern.length; gap++) {const index = breakPattern[gap] + safeIn + offset;gapIndexes.push(index);const brokenRock = config.bridge[index];brokenRock.dynamics.vy = DROP_VY;brokenRock.dynamics.ay = DROP_AY;const promise = new Promise((resolve) => {const adjuster = new hcjeLib.sprites.TerminateOutOfBounds(brokenRock, config.gameBounds);adjuster.onCompletion = (reason) => resolve();brokenRock.adjuster = adjuster;});promises.push(promise);}config.animator.active = true;return Promise.all(promises).then(() => {config.animator.active = false;return gapIndexes.sort((a, b) => a - b);});}function repairBridge(config) {const promises = [];for (const rock of config.bridge) {const rockDims = rock.dimensions;if (rock.position.y !== config.floorY) {rock.dynamics.vy = DROP_VY;rock.dynamics.ay = DROP_AY;rock.position = {x: rock.position.x, y: -rockDims.height, angle: 0};const promise = new Promise((resolve) => {const adjuster = new hcjeLib.sprites.ReachTargetXY(rock, rock.position.x, config.floorY);adjuster.onCompletion = (reason) => resolve();rock.adjuster = adjuster;});promises.push(promise);}}config.animator.active = true;return Promise.all(promises);}function findNoGoIndices(leaderIndex, bridgeGaps, lag) {let noGoIndices = [];for (let n = 0; n < lag; n++) {noGoIndices.push(leaderIndex + 1 + n);}for (let n = 1; n < bridgeGaps.length; n++) {const gapIndex = bridgeGaps[n];for (let lookBehind = n - 1; lookBehind >= 0; lookBehind--) {let noGoIndex = leaderIndex + gapIndex - bridgeGaps[lookBehind];noGoIndices.push(noGoIndex - 1);for (let n = 0; n <= lag; n++) {noGoIndices.push(noGoIndex + n);}}}return noGoIndices;}function getWalkerIndex(startIndex, noGoIndices) {while (noGoIndices.includes(startIndex)) {startIndex++;}return startIndex;}function getProcessionIndices(count, bridgeGaps, options) {const spread = options?.spread ?? 1;const processionIndices = [0];let leaderIndex = 0;let noGoIndices = [];while (--count) {noGoIndices = [...noGoIndices, ...findNoGoIndices(leaderIndex, bridgeGaps, options.walkerLag)];let spreadPlace = spread <= 1 ? 1 : hcjeLib.utils.getRandomIntInclusive(1, spread);while (spreadPlace-- > 0) {leaderIndex = getWalkerIndex(leaderIndex + 1, noGoIndices);}processionIndices.push(leaderIndex);}LOGGER.debug(`  Bridge gaps: ${bridgeGaps.join(', ')}`);LOGGER.debug(`   Procession: ${processionIndices.join(', ')}`);return processionIndices;}function startProcession(config) {const promises = [];const result = {success: false,count: 0,};const walkerCount = config.indices.length;let allWalkers = [];for (const index of config.indices) {const walker = createWalker(config.textureManager, allWalkers.length === config.indices.length - 1);allWalkers.push(walker);const walkerDims = walker.dimensions;walker.position = {x: -index * config.rockWidth - walkerDims.width,y: config.floorY - walkerDims.height}walker.dynamics.vx = config.walkSpeeds.normal;config.animator.addTarget(walker);const adjuster = new WalkerAdjuster(walker, {allowance: 8,bridgeGaps: config.bridgeGaps,gameBounds: config.gameBounds,onCompletion: (reason) => console.debug(`Walker completed: ${reason}`),rockWidth: config.rockWidth,scaffold: config.scaffold,walkSpeeds: config.walkSpeeds,walkerLag: config.walkerLag,lastWalker: allWalkers.length === config.indices.length,unsafeCounter: config.unsafeCounter});walker.adjuster = adjuster;const promise = new Promise((resolve) => {adjuster.onCompletion = (reason) => {console.debug(`Walker completed: ${reason}`);if (reason == 'CROSSED') {result.count++;console.debug(`Walker crossed. ${result.count}/${walkerCount}`);config.scoreboard.increment();if (result.count === walkerCount) {killWalkers(allWalkers);allWalkers = undefined;result.success = true;resolve(result);}} else {killWalkers(allWalkers);allWalkers = undefined;console.debug(`Walker fell. ${result.count}/${walkerCount}`);resolve(result);}}});promises.push(promise);}config.animator.active = true;return Promise.any(promises);}function killWalkers(walkers) {if (!walkers) {return;}for (const walker of walkers) {walker.renderer.style.opacity = 0;}setTimeout(() => {for (const walker of walkers) {walker.kill();}}, 2000);}function dropInScaffold(config) {const scaffoldDims = config.scaffold.dimensions;config.scaffold.position = {x: 0, y: -scaffoldDims.height, angle: 0};const adjuster = new hcjeLib.sprites.ReachTargetXY(config.scaffold, 0, config.floorY);config.animator.addTarget(config.scaffold);config.scaffold.adjuster = adjuster;config.scaffold.dynamics.vy = DROP_VY;config.scaffold.dynamics.ay = DROP_AY;return new Promise((resolve) => {adjuster.onCompletion = () => resolve();config.animator.active = true;}).then(()=> config.animator.active = false);}function flySpaceshipAcross(config) {config.spaceship.position = {x: config.bounds.x + config.bounds.width, y: config.y};config.spaceship.dynamics.vx = -Math.abs(config.speed);const adjuster = new hcjeLib.sprites.ReachTargetXY(config.spaceship, config.bounds.x - config.spaceship.dimensions.width, config.y);config.spaceship.adjuster = adjuster;hcjeLib.audio.getAudioManager().playAudioSfx(ROCKET_SFX_KEY);return new Promise((resolve) => {adjuster.onCompletion = () => resolve();config.animator.active = true;}).then(() => config.animator.active = false);}class ControlButtons {#left;#right;constructor(container, scaffoldAdjuster) {this.#left = new hcjeLib.domTools.Button({parentElement: container,className: 'bridger-control',url: './bridger/assets/images/retro_buttons_left.png',label: '',onClick: () => scaffoldAdjuster.moveLeft(),interval: {delay: 0, repeat: 0}});this.#right = new hcjeLib.domTools.Button({parentElement: container,className: 'bridger-control',url: './bridger/assets/images/retro_buttons_right.png',label: '',onClick: () => scaffoldAdjuster.moveRight(),interval: {delay: 0, repeat: 0}});this.#left.classList.add('bridger-control--left');this.#right.classList.add('bridger-control--right');LOGGER.info(`Control button events: left: ${this.#left.eventType}; right: ${this.#right.eventType}`);}set disabled(disabled) {this.#left.disabled = disabled;this.#right.disabled = disabled;}hide() {this.#left.style.opacity = 0;this.#right.style.opacity = 0;}show() {this.#left.style.opacity = 1;this.#right.style.opacity = 1;}}function startMusic() {const audio = hcjeLib.audio.getAudioManager();audio.gain = 0.5;audio.setMusic(SYNTH_DEFINITION);}class UnsafeWalkerCounter {#unsafe;constructor(unsafe) {this.#unsafe = unsafe;}get unsafe() {return this.#unsafe;}isJustOneLeft() {return this.#unsafe === 1;}areAllSafe() {return this.#unsafe <= 0;}decrement() {this.#unsafe--;}}async function gameLoop(config) {startMusic();hcjeLib.audio.getAudioManager().addAudioSfx(FALL_SFX_DEFINITION);hcjeLib.audio.getAudioManager().addAudioSfx(ROCKET_SFX_DEFINITION);let walkers = [];let playing = true;const scoreboard = new Scoreboard('Astronauts across: ', '');config.gameArea.appendChild(scoreboard)const animator = new hcjeLib.sprites.Animator();const bridge = await createBridge(animator, config.gameArea, config.textureManager);const rockFloor = bridge[0].position.y;const rockWidth = bridge[0].dimensions.width;const scaffold = createScaffold(config.textureManager);const spaceship = createSpaceship(config.textureManager);spaceship.position = {x: -spaceship.dimensions.width, y: -spaceship.dimensions.height};animator.addTarget(spaceship);await dropInScaffold({animator,scaffold,floorY: rockFloor});scaffold.adjuster = new ScaffoldAdjuster(scaffold, {bridge, speed: SCAFFOLD_SPEED_X });new ControlButtons( document.getElementsByClassName('hcje-game-area-container')[0],scaffold.adjuster).hide();const difficultyMgr = new DifficultyManager({bridgeLength: bridge.length,bridgeSafeLeft: BRIDGE_SAFE_IN,bridgeSafeRight: BRIDGE_SAFE_OUT,});difficultyMgr.difficulty = config.difficulty;while (playing) {const walkerLag = 1;animator.active = false;const bridgeGaps = await breakBridge({animator,bridge,gameBounds: config.gameArea.designBounds,gaps: difficultyMgr.gapCount,minBreakSpan: difficultyMgr.minimumBreakSpan,minLand: difficultyMgr.minimumLand,maxLand: difficultyMgr.maximumLand,safeIn: BRIDGE_SAFE_IN,safeOut: BRIDGE_SAFE_OUT,});const processionIndices = getProcessionIndices(difficultyMgr.processionLength, bridgeGaps, {spread: difficultyMgr.walkerSpread,walkerLag});const unsafeCounter = new UnsafeWalkerCounter(processionIndices.length);const walkSpeeds = difficultyMgr.calcWalkSpeeds({bridgeGaps,rockWidth: bridge[0].dimensions.width,scaffoldSpeed: SCAFFOLD_SPEED_X,walkerLag,});await flySpaceshipAcross({animator,spaceship,bounds: config.gameArea.designBounds,speed: SPACESHIP_SPEED_X,y: rockFloor - 1.2 * spaceship.dimensions.height});await hcjeLib.utils.sleep(750);await startProcession({animator,gameBounds: config.gameArea.designBounds,bridgeGaps,indices: processionIndices,floorY: rockFloor,rockWidth,scaffold,scoreboard,textureManager: config.textureManager,walkerLag,walkSpeeds,unsafeCounter,}).then((result) => {if (result.success) {difficultyMgr.incrementProcessions();} else {difficultyMgr.reset();return showResultAndReplay(config.gameArea, scoreboard);}}).then((difficulty) => {if (difficulty) {difficultyMgr.difficulty = difficulty;}}).then(() => repairBridge({animator,bridge,floorY: rockFloor}));}}const Difficulty = {SLOW: 0,NORMAL: 1,FAST: 2,}class DifficultyManager {#processions;difficulty;#gaps;constructor(config) {this.#gaps = 2;this.reset();}reset() {this.#processions = 0;}get walkerSpread() {return hcjeLib.utils.tossCoin() ? 1 : 2;}#calcMaxWalkSpeed(indicesToMove, config) {const timeToMoveOneGap = config.rockWidth / config.scaffoldSpeed;const maxTraversalTime = indicesToMove * (timeToMoveOneGap + 1 / CLICKS_PER_S);const maxWalkerSpeed = config.walkerLag * config.rockWidth / maxTraversalTime;LOGGER.debug(`Indices to move ${indicesToMove}; walker lag ${config.walkerLag} rocks`);LOGGER.debug(`Speed ${config.scaffoldSpeed} px/s; max traversal time ${maxTraversalTime.toFixed(2)} s; max walker speed ${maxWalkerSpeed.toFixed(2)}`);return maxWalkerSpeed;}#calcIndicesMovement(bridgeGaps, fullSpan) {if (fullSpan) {return bridgeGaps[bridgeGaps.length - 1] - bridgeGaps[0];} else {let movement = 0;for (let n = 1; n < bridgeGaps.length; n++) {movement = Math.max(movement, bridgeGaps[n] - bridgeGaps[n - 1]);}return movement;}}calcWalkSpeeds(config) {const maxWalkerSpeed = this.#calcMaxWalkSpeed(this.#calcIndicesMovement(config.bridgeGaps, true), config);const maxLastWalkerSpeed = this.#calcMaxWalkSpeed(this.#calcIndicesMovement(config.bridgeGaps, false), config);let minFactor;switch (this.difficulty) {case Difficulty.SLOW:minFactor = 0.3;break;case Difficulty.FAST:minFactor = 0.8;break;default:minFactor = 0.65;break;}const factor = Math.min(MAX_CLICKS_PER_S / CLICKS_PER_S, minFactor + 0.035 * this.#processions);const walkSpeed = factor * maxWalkerSpeed;LOGGER.debug(`Speed factor ${factor.toFixed(2)}`);const speeds = {normal: factor * maxWalkerSpeed,last: factor * maxLastWalkerSpeed,entry: ENTRY_SPEED,exit: MIN_EXIT_SPEED};LOGGER.debug(`Speeds: normal: ${speeds.normal.toFixed(1)}, last: ${speeds.last.toFixed(1)}`);return speeds;}get minimumBreakSpan() {return 4;}get minimumLand() {return this.#gaps < 3 ? 1 : 0;}get maximumLand() {return 3;}get gapCount() {return this.#gaps;}get processionLength() {return 1 + this.#processions;}incrementProcessions() {this.#processions++;this.#gaps = hcjeLib.utils.getRandomIntInclusive(2, 3);}}class WalkerAdjuster extends hcjeLib.sprites.BaseSpriteAdjuster {#allowance;#bottom;#bridgeGaps;#complete;#entering;#entryIndex;#exiting;#falling;#lastGapIndex;#lastWalker;onCompletion;#right;#rockWidth;#scaffold;#walkSpeeds;#unsafeCounter;constructor(sprite, config) {super(sprite);this.#allowance = config.allowance ?? 0;this.#bridgeGaps = config.bridgeGaps;this.#entering = true;this.#entryIndex = config.bridgeGaps[0] - 1 - config.walkerLag;this.#exiting = false;this.#lastGapIndex = this.#bridgeGaps[this.#bridgeGaps.length - 1];this.onCompletion = config.onCompletion;this.#right = config.gameBounds.x + config.gameBounds.width;this.#bottom = config.gameBounds.y + config.gameBounds.height;this.#rockWidth = config.rockWidth;this.#falling = false;this.#scaffold = config.scaffold;this.#walkSpeeds = config.walkSpeeds;this.#lastWalker = config.lastWalker;this.#unsafeCounter = config.unsafeCounter;console.debug(`Astronaut is last walker: ${this.#lastWalker}`);}adjust(timeStamp, deltaT) {const sprite = this._sprite;const position = sprite.position;let reason;if (position.x > this.#right && sprite.dynamics.vy === 0) {reason = 'CROSSED';}if (position.y > this.#bottom) {reason = 'FELL';}if (reason) {this.markComplete(reason);sprite.kill();return;}const centreX = position.x + sprite.dimensions.width / 2;const bridgeIndex = Math.floor(centreX / this.#rockWidth);if (!this.#falling && this.#bridgeGaps.includes(bridgeIndex)) {const scaffoldBounds = this.#scaffold.bounds;if (centreX < scaffoldBounds.x - this.#allowance ||centreX > scaffoldBounds.x + scaffoldBounds.width + this.#allowance) {this.#falling = true;sprite.dynamics.vAngle = 3;sprite.dynamics.vy = 40;sprite.dynamics.ay = 100;sprite.state = 'fall';setTimeout(()=> hcjeLib.audio.getAudioManager().playAudioSfx(FALL_SFX_KEY), 250);}}if (this.#entering && bridgeIndex >= 0) {sprite.dynamics.vx = this.#walkSpeeds.entry;}if (this.#entering && bridgeIndex >= this.#entryIndex) {this.#entering = false;sprite.dynamics.vx = this.#walkSpeeds.normal;}if (!this.#exiting && bridgeIndex >= this.#lastGapIndex + 1) {this.#exiting = true;this.#unsafeCounter.decrement();sprite.dynamics.vx = Math.max(sprite.dynamics.vx, this.#walkSpeeds.exit);}if (this.#lastWalker && this.#unsafeCounter.isJustOneLeft() && bridgeIndex > this.#bridgeGaps[0]) {sprite.dynamics.vx = Math.max(sprite.dynamics.vx, this.#walkSpeeds.last);}}}export class ScaffoldAdjuster extends hcjeLib.sprites.BaseSpriteAdjuster {bridge;#keyboard;#index;#lastX;#overlap;#targetX;vx;constructor(sprite, config) {super(sprite);this.bridge = config.bridge;this.vx = Math.abs(config.speed);this.#index = 0;this.#lastX = 0;this.#overlap = 0.5 * (sprite.dimensions.width - config.bridge[0].dimensions.width);this.#keyboard = new hcjeLib.device.Keyboard();for (const key of config.leftKeys ?? ['a', 'A', 'ArrowLeft']) {this.#keyboard.addDownListener(key, {callback: () => this.moveLeft(), noRepeat: true});}for (const key of config.rightKeys ?? ['d', 'D', 'ArrowRight']) {this.#keyboard.addDownListener(key, {callback: () => this.moveRight(), noRepeat: true});}}adjust(timeStamp, deltaT) {const sprite = this._sprite;if (this.#targetX === undefined) {return;}const position = sprite.position;if (this.vx > 0 && position.x < this.#targetX) {sprite.dynamics.vx = this.vx;} else if (this.vx < 0 && position.x > this.#targetX) {sprite.dynamics.vx = this.vx;} else {sprite.dynamics.vx = 0;position.x = this.#targetX;this.#targetX = undefined;}this.#lastX = position.x;}#updateTargetX() {this.#targetX = this.bridge[this.#index].position.x - this.#overlap;this.vx = this.#targetX >= this.#lastX ? Math.abs(this.vx) : -Math.abs(this.vx);}moveRight() {if (!this.#targetX) {if (this.#index < this.bridge.length - 1) {this.#index++;this.#updateTargetX();}}}moveLeft() {if (!this.#targetX) {if (this.#index > 0) {this.#index--;this.#updateTargetX();}}}}class Scoreboard extends hcjeLib.domTools.TextElement {prefix;suffix;#score;#bestEverScore;constructor(prefix = '', suffix = '') {super('div');this.prefix = prefix;this.suffix = suffix;this.classList.add('bridger-score');this.reset();}get score() {return this.#score;}#updateText() {let bestSuffix = '';if (this.#bestEverScore > 0) {bestSuffix = `: previous best was ${this.#bestEverScore}`;}this.innerText = `${this.prefix}${this.#score}${this.suffix}${bestSuffix}`;}increment() {this.#score++;this.#updateText();}reset() {this.#score = 0;this.#bestEverScore = hcjeLib.storage.getItem('BEST_SCORE') ?? 0;this.#updateText();}isNewBest() {return this.#score > this.#bestEverScore;}saveIfNewBest() {if (this.#score > this.#bestEverScore) {this.#bestEverScore = this.#score;hcjeLib.storage.setItem('BEST_SCORE', this.#score);}}}function factoryReset() {return hcjeLib.domTools.createDialog({title : 'Confirm factory reset',text: 'Are you sure you want to clear all saved data. This will get rid of your best score.',buttonDefns: [{id:'OK', url: './bridger/assets/images/retro_buttons_ok.png'},{id:'CANCEL', url: './bridger/assets/images/retro_buttons_cancel.png'},]}).then((id) => {if (id === 'OK') {LOGGER.warn('Factory reset select. Best score removed.');hcjeLib.storage.clear(STORAGE_KEY_PREFIX);}});}function showDebugLog() {return hcjeLib.domTools.createDialog({title: 'Debug log',className: 'bridger-debug-log',markdown: `${hcjeLib.buildConstants.BUILD_DATA.buildDateIso}\n\n.${navigator.userAgent}\n${LOGGER.markdown}`,buttonDefns: [{id:'OK', url: './bridger/assets/images/retro_buttons_ok.png'}]});}function showAboutDialog() {const reset = new hcjeLib.domTools.ButtonControl({label: 'Factory reset',url: './bridger/assets/images/retro_buttons_factory_reset.png',onClick: () => factoryReset()});const debug = new hcjeLib.domTools.ButtonControl({label: 'Debugging log',url: './bridger/assets/images/retro_buttons_debug.png',onClick: () => showDebugLog()});return hcjeLib.utils.fetchText('./bridger/assets/data/about.md', 'Cannot find about information.').then((aboutContent) => hcjeLib.domTools.createDialog({title: 'Bridge over Jupiter',markdown: aboutContent,children: [reset, debug],buttonDefns: [{id:'OK', url: './bridger/assets/images/retro_buttons_ok.png'}]}));}function showPlayDialog(parentElement, title, message) {const about = new hcjeLib.domTools.Button({className: 'bridger-dialog__about_button',label: 'About',url: './bridger/assets/images/retro_buttons_info.png',onClick: () => showAboutDialog()});return hcjeLib.domTools.createDialog({title,markdown: message,children: [about],buttonDefns: [{id: 'SLOW', label: 'Slow', url: './bridger/assets/images/retro_buttons_play_slow.png'},{id: 'NORMAL', label: 'Normal', url: './bridger/assets/images/retro_buttons_play.png'},{id: 'FAST', label: 'Fast', url: './bridger/assets/images/retro_buttons_play_fast.png'},]}).then((id) => {switch (id) {case 'SLOW': return Difficulty.SLOW;case 'FAST': return Difficulty.FAST;default: return Difficulty.NORMAL;}});}function showWelcomeAndPlay(container) {return hcjeLib.utils.fetchText('./bridger/assets/data/welcome.md', 'Could not load text. Please check your internet connection.').then((content) => showPlayDialog(container, 'Bridge over Jupiter', content));}function showResultAndReplay(container, scoreboard) {const walkersAcross = scoreboard.score;let title = 'Game over!';if (scoreboard.isNewBest()) {title = 'NEW BEST!';scoreboard.saveIfNewBest();}const message = `You managed to get ${walkersAcross} ${walkersAcross === 1 ? 'astronaut' : 'astronauts'} across. Can you save more next time?`;return showPlayDialog(container, title, message).then((difficulty) => {scoreboard.reset(); // in case factory reset selectedreturn difficulty;});}function addMenu(animator) {return hcjeLib.utils.fetchText('./bridger/assets/data/about.md', 'Cannot find about information.').then((aboutContent) => {const about = new hcjeLib.domTools.Button({label: 'About', url: './bridger/assets/images/retro_buttons_info.png', onClick: () => {animator.pause();hcjeLib.domTools.createDialog({title: 'Bridge over Jupiter',markdown: aboutContent,buttonDefns: [{id:'OK', url: './bridger/assets/images/retro_buttons_ok.png'}]}).then(() => animator.resume());}});const menu = new hcjeLib.domTools.MenuBar({opener: new hcjeLib.domTools.Button({label: 'Open menu', url: './bridger/assets/images/retro_buttons_menu.png'}),closer: new hcjeLib.domTools.Button({label: 'Close menu', url: './bridger/assets/images/retro_buttons_cancel.png'}),children: [about],});return menu;});}async function startGame() {const loading = document.getElementById('bridger-loading');loading.style.opacity = 0;setTimeout(()=>loading.remove(), 1000);hcjeLib.storage.setStorageKeyPrefix(STORAGE_KEY_PREFIX);const gameArea = new hcjeLib.domTools.GameArea({width: GAME_WIDTH,height: GAME_HEIGHT,});const title = new hcjeLib.domTools.createChild(gameArea, 'p', 'bridger-title');title.innerText = 'Bridge over Jupiter';const textureManager = await createTextureManager(gameArea, 'bridger/assets/images/sprites.json', 'bridger/assets/images/sprites.png');showWelcomeAndPlay(gameArea).then((difficulty) => {if (!/itch.io$/.test(window.location.hostname)) {hcjeLib.device.enterFullscreen(); // not needed on itch.}gameLoop({gameArea, difficulty, textureManager});});}startGame();