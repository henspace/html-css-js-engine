/* Copyright 2025 Steve Butler (henspace.com)
 * License: MIT
 */
import * as utils from './utils.js';import * as domTools from './dom-tools.js';export const CycleType = {NONE: 0,LOOP: 1,OSCILLATE: 2,STOP: 3};export class DomTextSpriteRenderer extends domTools.TextElement {constructor(container, txt, options) {super();container.appendChild(this);if (options?.markdown) {this.setMarkdown(txt);} else {this.innerText = txt;}this.className = 'hcje-sprites-sprite hcje-sprites-sprite--text';this.style.position = 'absolute';}render(sprite) {const frameData = sprite.frameData;const position = sprite.position;let transform = '';if (frameData.flipX) {transform += 'scaleX(-1) ';}if (frameData.flipY) {transform += 'scaleY(-1) ';}if (position.angle !== 0) {transform += ` rotateZ(${position.angle}rad)`;}this.style.opacity = sprite.opacity;this.style.width = `${frameData.width}px`;if (frameData.height) {this.style.height = `${frameData.height}px`;}this.style.transform =  transform;this.style.left = `${position.x}px`;this.style.top = `${position.y}px`;}kill() {this.remove();}}export function createTextSprite(container, txt, options) {const sprite = new Sprite('Text');const renderer = new DomTextSpriteRenderer(container, txt, options);sprite.renderer = renderer;const rect = {x: 0, y: 0, width: options.dimensions.width, height: options.dimensions.height};sprite.setStateFrames('anon', {cycleType: CycleType.NONE,frames: [rect],interval: 0});sprite.renderer.render(sprite);console.debug(`${renderer.offsetWidth} ${renderer.offsetHeight} `);sprite.dimensions = {width: renderer.offsetWidth, height: renderer.offsetHeight}return sprite;}export class DomImageSpriteRenderer extends domTools.ElementWrapper {#texture;constructor(container, texture) {super('div');container.appendChild(this);this.#texture = texture;this.className = 'hcje-sprites-sprite hcje-sprites-sprite--texture';this.style.backgroundImage = `url(${this.#texture.src})`;this.style.position = 'absolute';}render(sprite) {const frameData = sprite.frameData;const position = sprite.position;let transform = '';if (frameData.flipX) {transform += 'scaleX(-1) ';}if (frameData.flipY) {transform += 'scaleY(-1) ';}if (position.angle !== 0) {transform += ` rotateZ(${position.angle}rad)`;}this.style.opacity = sprite.opacity;this.style.width = `${frameData.width}px`;this.style.height = `${frameData.height}px`;this.style.transform =  transform;this.style.left = `${position.x}px`;this.style.top = `${position.y}px`;this.style.backgroundPosition = `-${frameData.x}px -${frameData.y}px`;}kill() {this.remove();}}export class Sprite {#adjuster;autoFlipX;autoFlipY;dynamics;#flipX;#flipY;#frameInc;#frames;#frameIndex;#height;logId;#interval;opacity;#position;#state;#stateData;#killed;#cycleType;#texture;#width;constructor(logId) {this.logId = logId;this.#interval = 0;this.#frameInc = 1;this.#stateData = new Map();this.#position = {x: 0, y: 0, angle: 0};this.#killed = false;}get adjuster() {return this.#adjuster;}set adjuster(adjuster) {if (this.#adjuster) {this.#adjuster.onCompletion = undefined;this.#adjuster.markComplete();}this.#adjuster = adjuster;}static deriveWalk(dynamics, distPerFrame) {return 1000 * distPerFrame / Math.abs(dynamics.vx);}setStateFrames(stateName, stateConfig) {if (stateConfig.frames?.length > 0) {this.#stateData.set(stateName, stateConfig);} else {console.warn(`Cannot set state ${stateName} as there are no frames.`);}if (this.#stateData.size === 1) {this.state = stateName;}}get dimensions() {return {width: this.#width, height: this.#height};}set dimensions(dims) {this.#width = dims.width;this.#height = dims.height;}get bounds() {return {x: this.#position.x, y: this.#position.y, width: this.#width, height: this.#height};}get state() {return this.#state;}set state(state) {console.debug(`Set ${this.logId} state to ${state}.`);const stateConfig = this.#stateData.get(state);if (stateConfig) {const frames = stateConfig.frames;this.#interval = stateConfig.interval;this.#cycleType = stateConfig.cycleType ?? CycleType.LOOP;this.#state = state;this.#width = frames[0].width;this.#height = frames[0].height;this.#frames = frames;this.#frameIndex = 0;this.#updateFrame();} else {console.debug(`Could not find state ${state} for ${this.logId}`);}}isKilled() {return this.#killed;}get frameData() {return this.#frames[this.#frameIndex]}#updateFrame() {const frameData = this.#frames[this.#frameIndex];frameData.flipX = this.#flipX;frameData.flipy = this.#flipY;this.renderer?.render(this);}#handleDynamics(timeStamp, deltaT) {this.dynamics.adjustSprite(timeStamp, deltaT, this);this.#flipX = this.autoFlipX && this.dynamics.vx < 0;this.#flipY = this.autoFlipY && this.dynamics.vy < 0;}update(timeStamp, deltaT) {if (this.dynamics) {this.#handleDynamics(timeStamp, deltaT);}if (this.#adjuster) {this.#adjuster.adjust(timeStamp, deltaT);if (this.#adjuster.isComplete()) {this.#adjuster = undefined;}}const interval = typeof this.#interval === 'function' ? this.#interval(this.dynamics) : this.#interval;if (interval > 0 && this.#frames.length > 1) {const index = Math.floor((timeStamp / interval)) % this.#frames.length;if (index != this.#frameIndex) {this.#frameIndex += this.#frameInc;if (this.#frameIndex >= this.#frames.length) {if (this.cycleType === CycleType.OSCILLATE) {this.#frameIndex -= 2;this.#frameInc = -1;} else if (this.#cycleType === CycleType.STOP) {this.#frameIndex--;this.#interval = 0;}else {this.#frameIndex = 0;}} else if (this.#frameIndex < 0) {this.#frameIndex = 1;this.#frameInc = 1;}}}this.#updateFrame();}get position() {return this.#position;}set position(position) {this.#position = position;if (position.angle === undefined) {this.#position.angle = 0;}this.#updateFrame();}kill() {this.renderer?.kill();this.#killed = true;}}export class Bouncer {#bottom;#left;#right;#top;constructor(actorDims, boundary) {this.#left = boundary.x;this.#right = boundary.x + boundary.width - actorDims.width;this.#top = boundary.y;this.#bottom = boundary.y + boundary.height - actorDims.height;}limit(target, dynamics) {if (target.position.x < this.#left) {target.position.x = this.#left;dynamics.vx = Math.abs(dynamics.vx);}if (target.position.x > this.#right) {target.position.x = this.#right;dynamics.vx = -Math.abs(dynamics.vx);}if (target.position.y < this.#top) {target.position.y = this.#top;dynamics.vy = Math.abs(dynamics.vy);}if (target.position.y > this.#bottom) {target.position.y = this.#bottom;dynamics.vy = -Math.abs(dynamics.vy);}}}export class Dynamics {static #twoPI = 2 * Math.PI;aAngle;ax;ay;limiter;vAngle;vx;vy;constructor(limiter) {this.limiter = limiter;this.vx = 0;this.vy = 0;this.vAngle = 0;this.ax = 0;this.ay = 0;this.aAngle = 0;}adjustSprite(timeStamp, deltaT, sprite) {let position = sprite.position;position.x += deltaT * this.vx;position.y += deltaT * this.vy;position.angle += deltaT * this.vAngle;this.vx += deltaT * this.ax;this.vy += deltaT * this.ay;this.vAngle += deltaT * this.aAngle;position.angle = position.angle % Dynamics.#twoPI;position.angle = position.angle % Dynamics.#twoPI;this.limiter?.limit(sprite, this);}isMoving() {return this.vx || this.vy || this.vAngle || this.aX || this.aY || this.aAngle;}}export class DomImageSpriteFactory {parentElement;constructor(parentElement) {this.parentElement = parentElement;}createSprite(logId, texture) {const sprite = new Sprite(logId);sprite.renderer = new DomImageSpriteRenderer(this.parentElement, texture);return sprite;}}export class TextureManager {#data;spriteFactory;#texture;constructor(data, texture, spriteFactory) {this.#data = data;this.#texture = texture;}createFrameName(baseName, state, frameIndex) {return baseName.replace(/^(?<prefix>.*)(?<suffix>\.[^.]*)$/, `\$<prefix>_${state}${frameIndex}\$<suffix>`);}#createRectData(tpEntry) {return {x: tpEntry.frame.x,y: tpEntry.frame.y,width: tpEntry.frame.w,height: tpEntry.frame.h,}}createSprite(baseName, stateConfigs, frameNameGenerator) {if (!this.spriteFactory) {throw new Error("You must set the spriteFactory property before calling the TextureManager's createSprite method.");}const nameGen = frameNameGenerator ?? this.createFrameName;const sprite = this.spriteFactory.createSprite(baseName, this.#texture);if (!stateConfigs || stateConfigs.length === 0) {sprite.setStateFrames('anon', {cycleType: CycleType.NONE,frames: [this.#createRectData(this.#data.frames[baseName])],interval: 0});return sprite;}for (const stateConfig of stateConfigs) {let frameInfo;const frameData = [];let frameIndex = 0;while(true) {const frameName = nameGen(baseName, stateConfig.name, frameIndex++);frameInfo = this.#data.frames[frameName];if (!frameInfo) {break;} else {frameData.push(this.#createRectData(frameInfo));}}if (frameData.length === 0) {frameInfo = this.#data.frames[baseName];if (frameInfo) {frameData.push(this.#createRectData(frameInfo));}}sprite.setStateFrames(stateConfig.name, {cycleType: stateConfig.cycleType ?? CycleType.LOOP,frames: frameData,interval: stateConfig.interval});}return sprite;}}function loadImage(source) {const image = new Image();return new Promise((resolve) => {image.addEventListener('load', () => resolve(image), {once: true});image.src = source;});}export function loadSpriteSheet(dataUrl, textureUrl, busyIndicator) {busyIndicator?.start();let textureData;let textureManager;return utils.fetchJson(dataUrl).then((data) => {textureData = data;return loadImage(textureUrl);}).then((image) => textureManager = new TextureManager(textureData, image)).catch((error) => {console.error(`Failed to load spritesheet.: ${error}`);}).finally(() => {busyIndicator?.end();return textureManager;});}export class BaseSpriteAdjuster {#complete = false;onCompletion;_sprite;constructor(sprite) {this._sprite = sprite;this._complete = false;}isComplete() {return this.#complete;}markComplete(reason) {this._sprite = undefined; // releases circular references.this.#complete = true;this.onCompletion?.(reason);}adjust(timeStamp, deltaT) {}}export class TerminateOutOfBounds extends BaseSpriteAdjuster {#bottom;#kill;#left;#right;#top;constructor(sprite, bounds, kill = false) {super(sprite);this.#left = bounds.x;this.#right = bounds.x + bounds.width;this.#top = bounds.y;this.#bottom = bounds.y + bounds.height;this.#kill = kill;}adjust(timeStamp, deltaT) {const bounds = this._sprite.bounds;if (bounds.x + bounds.width < this.#left ||bounds.x > this.#right ||bounds.y + bounds.height < this.#top ||bounds.y > this.#bottom) {console.debug(`Terminate ${this._sprite.logId} as out of bounds`);if (this.#kill) {this._sprite.kill();}this._sprite.dynamics.vx = 0;this._sprite.dynamics.vy = 0;this._sprite.dynamics.ax = 0;this._sprite.dynamics.ay = 0;this.markComplete();}}}export class ReachTargetXY extends BaseSpriteAdjuster {#targetX;#targetY;constructor(sprite, targetX, targetY) {super(sprite);this.#targetX = targetX;this.#targetY = targetY;}targetReached(velocity, value, target) {if (velocity < 0) {return value <= target;} else {return value >= target;}}adjust(timeStamp, deltaT) {const position = this._sprite.position;if (this.targetReached(this._sprite.dynamics.vx, position.x, this.#targetX)) {this._sprite.dynamics.vx = 0;this._sprite.dynamics.ax = 0;position.x = this.#targetX;}if (this.targetReached(this._sprite.dynamics.vy, position.y, this.#targetY)) {this._sprite.dynamics.vy = 0;this._sprite.dynamics.ay = 0;position.y = this.#targetY;}if (this._sprite.dynamics.vx === 0 && this._sprite.dynamics.vy === 0) {this.markComplete();}}}export class Animator {#active;#children;#lastTimeStamp;#paused;constructor () {this.active = false;this.#paused = false;this.#children = new Map();}get active() {return this.#active;}set active(state) {if (!this.#active && state) {this.#active = state;this.#animate();} else {this.#lastTimeStamp = undefined;this.#active = state;}}pause() {this.#paused = true;this.#lastTimeStamp = undefined;}resume() {if (this.#paused) {this.#paused = false;if (this.#active) {this.#animate();}}}#animate(timeStamp) {if (!this.active || this.#paused) {return;}if (timeStamp) {const deltaT = this.#lastTimeStamp ? (timeStamp - this.#lastTimeStamp) / 1000 : 0;this.#lastTimeStamp = timeStamp;this.#children.forEach((target) => {target.update(timeStamp, deltaT);if (target.isKilled()) {this.#children.delete(target);}});}requestAnimationFrame((evtTimeStamp) => this.#animate(evtTimeStamp));}addTarget(target) {if (!target.update) {throw new Error('Target does not implement the hcje/sprites~AnimationTarget interface.');}this.#children.set(target, target);}killTarget(target) {const child = this.#children.get(target);if (child) {child.kill();}this.#children.delete(target);}clear() {this.#active = false;this.#children.forEach((child) => this.killTarget(child));}}