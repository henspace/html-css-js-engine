/* Copyright 2025 Steve Butler (henspace.com)
 * License: MIT
 */
export function parseInt(str, defaultValue = 0) {const result = Number.parseInt(str);return Number.isNaN(result) ? defaultValue : result;}export function getRandomNumberBetween(min, max) {return Math.random() * (max - min) + min;}export function getRandomIntExclusive(min, max) {if (max <= min) {return Math.ceil(min);}const minCeiled = Math.ceil(min);const maxFloored = Math.floor(max);return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);}export function getRandomIntInclusive(min, max) {if (max <= min) {return Math.ceil(min);}const minCeiled = Math.ceil(min);const maxFloored = Math.floor(max);return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled);}export function rollDice(sides = 6) {return getRandomIntInclusive(1, sides);}export function tossCoin() {return Math.random() >= 0.5;}export function getRandomMember(arr) {if (!arr || arr.length < 1) {return;}const index = getRandomIntExclusive(0, arr.length);return arr instanceof Array ? arr[index] : arr.charAt(index);}export function greatestCommonDivisor(valueA, valueB) {function calculate(a, b) {return b === 0 ? a : calculate(b, a % b);}return calculate(Math.floor(valueA), Math.floor(valueB));}export function lowestCommonMultiple(valueA, valueB) {return valueA * valueB / greatestCommonDivisor(valueA, valueB);}export function lowestCommonMultipleOfArray(values) {return values.reduce((a, b) => lowestCommonMultiple(a, b));}export function jitter(value, variation) {if (!variation) {return value;}const min = value * (1 - variation);const max = value * (1 + variation);return getRandomNumberBetween(min, max);}export function clamp(value, min, max) {return Math.min(Math.max(value, min), max);}export function sleep(ms) {return new Promise((resolve) => {setTimeout(() => resolve(), ms);});}export function createWaiter() {let resolver;const waiter = {wait: () => {return new Promise((resolve, reject) => {if (resolver) {reject(new Error(`Attempt to call wait on Waiter that is already awaiting resolution.`));} else {resolver = resolve;console.debug('Waiter set to wait for continue to be called.');}})},end: (value) => {if (!resolver) {console.error("Ignoring call made to end wait on a Waiter that hasn't been started.");} else {console.debug(`End wait. Fulfil as ${value}`);resolver(value);resolver = undefined;}},isWaiting: () => !!resolver,};return waiter;}export function shuffle(arr) {for (let i = arr.length-1; i > 0; i--) {var j = Math.floor(Math.random() * i);var tmp = arr[i];arr[i] = arr[j];arr[j] = tmp;}return arr;}const ContentType = {css: 'text/css',csv: 'text/csv',cur: 'image/x-icon',gif: 'image/gif',html: 'text/html',ico: 'image/x-icon',jpeg: 'image/jpeg',jpg: 'image/jpeg',json: 'application/json',js: 'text/javascript',map: 'application/json',md: 'text/markdown',mp3: 'audio/mpeg',mp4: 'video/mp4',mpeg: 'video/mpeg',png: 'image/png',svg: 'image/svg+xml',ttf: 'font/ttf',txt: 'text/plain',woff: 'font/woff',woff2: 'font/woff2',};export function fetchTextOrJson(url, asJson, fallbackResult) {return fetch(url).then((response) => {if (response.ok) {return asJson ? response.json() : response.text();} else {throw new Error(`HTTP error! Status :${response.status}`);}}).catch((error) => {console.error(error.message);if (fallbackResult === undefined) {throw new Error(`Failed to load ${url}: ${error}`);}return fallbackResult;});}export function fetchText(url, fallbackResult) {return fetchTextOrJson(url, false, fallbackResult);}export function fetchJson(url, fallbackResult) {return fetchTextOrJson(url, true, fallbackResult);}export function fetchArrayBuffer(url, options) {let requestInit = options;if (!requestInit) {const fileType = url?.match(/\.([\w\d]+)$/)?.[1];if (fileType) {requestInit = {method: 'GET',headers: {'Content-Type' :ContentType[fileType],}};console.debug(`Fetch ${url} with Content-Type = ${requestInit.headers['Content-Type']}`);}}return fetch(url, requestInit).then((response) => {if (response.ok) {return response.arrayBuffer();} else {throw new Error(`HTTP error! Status :${response.status}`);}})}