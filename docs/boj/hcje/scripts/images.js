/* Copyright 2025 Steve Butler (henspace.com)
 * License: MIT
 */
import * as utils from "./utils.js";export function textCellPainter(data) {const word = utils.getRandomMember(data.custom?.text ?? 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890');let fontSize = data.cell.height;data.context.font = `${fontSize}px ${data.custom?.fontName ?? 'sans-serif'}`;data.context.textBaseline = 'middle';if (data.custom?.fitWidth) {const textMetrics = data.context.measureText(word);fontSize = fontSize * data.cell.width / textMetrics.width;data.context.font = `${fontSize}px ${data.custom?.fontName ?? 'sans-serif'}`;}if (data.custom?.fill) {data.context.fillText(word, data.cell.x, data.cell.y + data.cell.height / 2);} else {data.context.strokeText(word, data.cell.x, data.cell.y + data.cell.height / 2);}}export function imageCellPainter(data) {if (!data.custom?.image) {console.error(`Image not provided in data.custom.image.`);return;}let height = data.cell.height;if (data.custom?.keepAspect && data.custom.image.width != 0) {height = data.cell.width * data.custom.image.height / data.custom.image.width;}data.context.drawImage(data.custom.image, data.cell.x, data.cell.y, data.cell.width, height);}export function circleCellPainter(data) {data.context.beginPath();data.context.arc(data.cell.x + data.cell.width / 2, data.cell.y + data.cell.height / 2,data.cell.width / 2, 0, 2 * Math.PI);if (data.custom?.fill) {data.context.fill();} else {data.context.stroke();}}export function triangleCellPainter(data) {const custom = data.custom ?? {};custom.points = [{x: data.cell.x, y: data.cell.y + data.cell.height},{x: data.cell.x + data.cell.width / 2, y: data.cell.y},{x: data.cell.x + data.cell.width, y: data.cell.y + data.cell.height},];const pathData = {context: data.context,imageSize: data.imageSize,cell: data.cell,custom,}pathCellPainter(pathData);}export function randomPathCellPainter(data) {const custom = data.custom ?? {};let vertices = Math.max(4, data.custom.vertices ?? 0);const points = [];points.push({x: data.cell.x + data.cell.width / 2, y: data.cell.y});points.push({x: data.cell.x + data.cell.width, y: data.cell.y + data.cell.height / 2});points.push({x: data.cell.x + data.cell.width / 2, y: data.cell.y + data.cell.height});points.push({x: data.cell.x, y: data.cell.y + data.cell.height / 2});for (let index = 4; index < data.cell.vertices; index++) {const x = utils.getRandomIntInclusive(data.cell.x, data.cell.x + data.cell.width);const y = utils.getRandomIntInclusive(data.cell.y, data.cell.y + data.cell.height);points.push({x, y});}custom.points = utils.shuffle(points);const pathData = {context: data.context,imageSize: data.imageSize,cell: data.cell,custom,}pathCellPainter(pathData);}export function pathCellPainter(data) {const points = data.custom.points;if (!points || points.length < 2) {console.error('Attempt to draw path with less than 2 points ignored.');return;}const path = new Path2D();path.moveTo(points[0].x, points[0].y);for (let index = 1; index < points.length; index++) {path.lineTo(points[index].x, points[index].y)}path.closePath();if (data.custom?.fill) {data.context.fill(path);} else {data.context.stroke(path);}}export class ImageGenerator {#cache = new Map();revokeCacheId(cacheId) {if (!this.#cache.has(cacheId)) {console.error(`Ignored attempt to revoke missing cache Id ${cacheId}`);return;}this.#cache.get(cacheId).revokeObjectURL();this.#cache.delete(cacheId);console.debug(`Revoked cache Id ${cacheId}`);}revokeAll() {this.#cache.forEach((url)=> url.revokeObjectURL());this.#cache.clear();}createObjectUrlOrUseCache(cacheId, config) {if (!cacheId) {return Promise.reject(new Error(`Attempt to create an image with no cache id rejected.`));}if (this.#cache.has(cacheId)) {return Promise.resolve(this.#cache.get(cacheId));} else {return this.createObjectUrl(config).then((url) => {if (cacheId) {this.#cache.set(cacheId, url);}return url;});}}createObjectUrl(config) {const backgroundColor = config.cellConfig?.backgroundColor ?? 'transparent';const jitter = config.cellConfig?.jitter ?? 0;const maxScale = config.cellConfig?.maxScale ?? 1;const minScale = config.cellConfig?.minScale ?? 1;const palette = config.cellConfig?.palette ?? ['black'];const rowCount = config.cellConfig?.rowCount ?? 1;const strokeWidth = config.cellConfig?.strokeWidth ?? 4;const strokeWithinCell = config.cellConfig?.strokeWithinCell ?? false;const canvas = document.createElement('canvas');const context = canvas.getContext('2d');canvas.width = config.imageSize.width;canvas.height = config.imageSize.height;context.fillStyle = backgroundColor;context.fillRect(0, 0, config.imageSize.width, config.imageSize.height);if (rowCount <= 0) {return Promise.reject(new Error(`Attempt made to create image with invalid rowCount of ${rowCount}`));}const cellSide = config.imageSize.height / rowCount;const columns = Math.ceil(config.imageSize.width / cellSide);for (let row = 0; row < rowCount; row++) {for (let col = 0; col < columns; col++) {const color = utils.getRandomMember(palette);const cellMargin = strokeWithinCell ? strokeWidth / 2 : 0;const cell = {x: cellMargin + col * cellSide + utils.getRandomNumberBetween(-cellSide * jitter, cellSide * jitter),y: cellMargin + row * cellSide + utils.getRandomNumberBetween(-cellSide * jitter, cellSide * jitter),width: utils.getRandomNumberBetween(cellSide * minScale, cellSide * maxScale) - 2 * cellMargin,height: utils.getRandomNumberBetween(cellSide * minScale, cellSide * maxScale) - 2 * cellMargin,}context.fillStyle = color;context.strokeStyle = color;context.lineWidth = strokeWidth;context.lineJoin = 'round';if (!config.cellPainter) {return Promise.reject(new Error(`No cell painter so image cannot be drawn.`));}config.cellPainter({context,imageSize: config.imageSize,cell,custom: config.custom})}}return new Promise((resolve) => {canvas.toBlob((blob) => {console.log(blob);resolve(URL.createObjectURL(blob));});});}}