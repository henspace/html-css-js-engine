/* Copyright 2025 Steve Butler (henspace.com)
 * License: MIT
 */
import * as utils from './utils.js';import * as device from './device.js';const MARKDOWN_REPS = [{re: /\r/g, rep: ''},{re:/(?:&(?!(\w{2,5}|#\d{2,5}|#x[0-9A-F]{2,5});))/gi , rep: '&amp;'},{re: /</g, rep: '&lt;'},{re: />/g, rep: '&gt;'},{re: /"/g, rep: '&quot;'},{re: /'/g, rep: '&apos;'},{re: /^[\+\-*] (.*)$/gm, rep: '<uli>$1</uli>'},{re: /<\/uli>\n<uli>/g, rep: '</uli><uli>'},{re: /\n((?:<uli>.*?<\/uli>)+)\n/gs, rep: '\n<ul>$1</ul>\n'},{re: /^[\d]+ (.*)$/gm, rep: '<oli>$1</oli>'},{re: /<\/oli>\n<oli>/g, rep: '</oli><oli>'},{re: /\n((?:<oli>.*?<\/oli>)+)\n/gs, rep: '\n<ol>$1</ol>\n'},{re: /[ou]li>/g, rep: 'li>'},{re: /^# (.*?)#?$/gm, rep: '<h1>$1</h1>'},{re: /^## (.*?)(?:##)?$/gm, rep: '<h2>$1</h2>'},{re: /^### (.*?)(?:###)?$/gm, rep: '<h3>$1</h3>'},{re: /^#### (.*?)(?:####)?$/gm, rep: '<h4>$1</h4>'},{re: /<\/(h\d|ul|ol)>\n*<(h\d|ul|ol)>/g, rep: '<\/$1><$2>'},{re: /([^>])\n{2,}([^<])/g, rep: '$1</p><p>$2'},{re: />\n+([^<])/g, rep: '><p>$1'},{re: /([^>])\n+</g, rep: '$1</p><'},{re: /^\s*([^<])/, rep: '<p>$1'},{re: /([^>])\s*$/g, rep: '$1</p>'},{re: /&lt;br&gt;/gmi, rep: '<br>'},{re: /`(.+?)`/gm, rep: '<code>$1</code>'},{re: /\*\*([^\n]+?)\*\*/gm, rep: '<strong>$1</strong>'},{re: /\*([^\n]+?)\*/gm, rep: '<em>$1</em>'},{re: /!\[([\w ,;.&-]+?)\]\(((?:https:\/\/|\.\/)[^\s?]+?)(?: *&quot;([\w ]*?)&quot;)?\)/gm, rep: '<img alt = "$1" src="$2" title="$3" />'},{re: /\[([\w ,;.&-]+?)\]\(((?:https:\/\/|\.\/)[^\s?]+?)(?: *&quot;([\w ]*?)&quot;)?\)/gm, rep: '<a href="$2" target="_blank" title="$3">$1</a>'},]export function parseMarkdown(markdown) {let html = markdown;for (const replacement of MARKDOWN_REPS) {html = html.replace(replacement.re, replacement.rep);}return html;}export function createChild(parentElement, tagName, className) {const child = document.createElement(tagName);if (className) {child.className = className;}parentElement.appendChild(child);return child;}export function createDivider(config) {const container = document.createElement('div');const baseClass = 'hcje-divider';container.className = baseClass;let align = config.alignment ? config.alignment.toUpperCase() : 'LEFT';if (align === 'CENTER' || align === 'RIGHT') {createChild(container, 'hr', `${baseClass}__hr`)}const label = createChild(container, 'span', `${baseClass}__label`);label.innerText = config.label;if (align === 'CENTER' || align === 'LEFT') {createChild(container, 'hr', `${baseClass}__hr`)}return container;}export class ElementWrapper {#element;constructor(elementType) {this.#element = elementType instanceof Element ? elementType : document.createElement(elementType);}get _element() {return this.#element;}get parentElement() {return this.#element.parentElement;}get className() {return this.#element.className;}set className(value) {this.#element.className = value;}get classList() {return this.#element.classList;}get offsetHeight() {return this.#element.offsetHeight;}get offsetWidth() {return this.#element.offsetWidth;}get style() {return this.#element.style;}addEventListener(eventType, listener, optionsOrUseCapture) {return this.#element.addEventListener(eventType, listener, optionsOrUseCapture);}appendChild(child) {return this.#element.appendChild(child instanceof ElementWrapper ? child._element : child);}appendTo(parentElement) {if (!parentElement) {return;}if (this.#element.parentElement) {console.error(`Attempt to append control as a child when it already has a parent. Ignored.`);return;} else {parentElement.appendChild(this.#element);}}remove() {this.#element.remove();}removeAllChildren() {this.#element.replaceChildren();}blur() {this.#element.blur();}focus() {this.#element.focus();}static _toElement(item) {return item instanceof ElementWrapper ? item._element : item;}}export class TextElement extends ElementWrapper {constructor() {super('div');this.className = 'hcje-text';}get innerText() {return this._element.innerText;}set innerText(txt) {this._element.innerText = txt;}setMarkdown(markdown) {this._element.innerHTML = parseMarkdown(markdown);}}const SIM_KBD_REPEAT_DELAY = 44;const SIM_KBD_REPEAT_INTERVAL = 33;export const SIM_KBD_INTERVAL = {delay: 750, repeat: 33};class ButtonRepeater {#callback;#interval;#intervalId;#timeoutId;#eventType;constructor(button, interval, callback) {console.debug(`Button repeat  interval`, interval);this.#interval = interval;this.#callback = callback;if (device.supportsTouch()) {console.debug('Use touch events.');this.#eventType = 'touch';button.addEventListener('touchstart', (evt) => this.#start(evt));button.addEventListener('touchend', (evt) => this.#end(evt));button.addEventListener('touchmove', (evt) => evt.preventDefault());button.addEventListener('touchcancel', (evt) =>this.#end(evt));} else {this.#eventType = 'pointer';button.addEventListener('pointerdown', (evt) => this.#start(evt));button.addEventListener('pointerup', (evt) => this.#end(evt));button.addEventListener('pointercancel', (evt) => this.#end(evt));button.addEventListener('pointerleave', (evt) => this.#end(evt));}}get eventType() {return this.#eventType;}#start(evt) {console.debug(`Button repeat start: ${evt.type}`);evt.preventDefault();this.#callback();if (this.#interval.delay) {this.#timeoutId = setTimeout(() => {this.#timeoutId = undefined;this.#repeat();}, this.#interval.delay);}}#repeat() {this.#callback();this.#intervalId = setInterval(() => this.#callback(), this.#interval.repeat);}#end(evt) {console.debug(`Button repeat end: ${evt.type}`);evt.preventDefault();if (this.#timeoutId) {clearTimeout(this.#timeoutId);} else {clearInterval(this.#intervalId);}}}export class Button extends ElementWrapper {#button;#buttonRepeater;#toggleButton;#buttonOn;#icon;#buttonText;#url;#urlOn;#label;#labelOn;#baseClass;#eventType;constructor(config) {super('button');this.#toggleButton = !!config.urlOn || (!config.url && config.labelOn);this.#url = config.url;this.#urlOn = config.urlOn;this.#label = config.label;this.#labelOn = config.labelOn;this.#buttonOn = !!config.down;this._element.tabindex = 0;this.#baseClass = this.#toggleButton ? 'hcje-toggle-button' : 'hcje-button';this._element.className = this.#baseClass;if (config.className) {this._element.classList.add(config.className);}this._element.classList.add(`${this.#baseClass}-${config.url ? 'image' : 'text'}`);if (config.url) {this.#icon = createChild(this._element, 'img', `${this.#baseClass}__icon`);} else {this._elementText = createChild(this._element, 'div', `${this.#baseClass}__label`);}this.#setButtonFace();this._element.title = config.label ?? '';config.parentElement?.appendChild(this._element);if (config.onClick && config.interval && !this.toggleButton) {this.#buttonRepeater = new ButtonRepeater(this, config.interval, config.onClick);this.#eventType = this.#buttonRepeater.eventType;}else if (config.onClick || this.#toggleButton) {this.#eventType = 'click';this.addEventListener('click', (ev) => {if (this.#toggleButton) {this.#buttonOn = !this.#buttonOn;this.#setButtonFace();}config?.onClick(ev, this.#buttonOn);});} else {this.#eventType = 'none';}this.addEventListener('contextmenu', (ev) => ev.preventDefault());this.addEventListener('dragstart', (ev) => ev.preventDefault());}get eventType() {return this.#eventType;}#setButtonFace() {if (!this.#toggleButton) {if (this.#icon) {this.#icon.src = this.#url;this.#icon.setAttribute('alt', this.#label);}if (this._elementText) {this._elementText.innerText = this.#label;}} else {if (this.#buttonOn) {if (this.#icon) {this.#icon.src = this.#urlOn;this.#icon.setAttribute('alt', this.#labelOn || this.#label);}if (this._elementText) {this._elementText.innerText = this.#labelOn;}this._element.classList.add(`${this.#baseClass}--down`);this._element.classList.remove(`${this.#baseClass}--up`);} else {if (this.#icon) {this.#icon.src = this.#url;this.#icon.setAttribute('alt', this.#label);}if (this._elementText) {this._elementText.innerText = this.#label;}this._element.classList.add(`${this.#baseClass}--up`);this._element.classList.remove(`${this.#baseClass}--down`);}}}isOn() {return this.#buttonOn;}get disabled() {return this._element.disabled;}set disabled(disabledState) {this._element.disabled = disabledState;}}class BaseControl extends ElementWrapper {constructor(className, config) {super('div');this._element.className = `hcje-base-control ${className}`const labelElement = createChild(this._element, 'div', 'hcje-base-control__label' );labelElement.innerText = config.label;this.appendTo(config.parentElement);}_appendControlElement(controlElement) {this._element.append(ElementWrapper._toElement(controlElement));}_prependControlElement(controlElement) {this._element.prepend(ElementWrapper._toElement(controlElement));}getValue() {console.error('BaseClass method getValue should be overridden.');}}export class ButtonControl extends BaseControl {#button;constructor(config) {super('hcje-button-control', config);this.#button = new Button({parentElement: this._element,url: config.url,urlOn: config.urlOn,on: config.on,label: config.label,labelOn: config.labelOn,className: config.className,onClick: config.onClick});this.appendTo(config.parentElement);}getValue() {return this.#button.isOn();}}export class CheckboxControl extends BaseControl {#box;#checked;#onChange;#checkedClassName;constructor(config) {super('hcje-checkbox-control', config);this.#box = document.createElement('div');this.#box.className  ='hcje-checkbox-control__box';this.#checkedClassName = `hcje-checkbox-control__box--checked-${config.tick ? 'tick' : 'cross'}`;this.#onChange = config.onChange;this.#box.addEventListener('click', () => {this.#setState(!this.#checked)this.#onChange?.(this.#checked);});this._prependControlElement(this.#box);this.#setState(!!config.initialValue);}#setState(checkedState) {this.#checked = checkedState;if (this.#checked) {this.#box.classList.add(this.#checkedClassName);this.#box.classList.remove('hcje-checkbox-control__box--unchecked');} else {this.#box.classList.remove(this.#checkedClassName);this.#box.classList.add('hcje-checkbox-control__box--unchecked');}}getValue() {return this.#checked;}}export class InputControl extends BaseControl {#input;#lastValidInput;constructor(config) {super('hcje-input-control', config);this.#input = document.createElement('input');this.#input.className = 'hcje-input-control__input';//this.#input.maxLength = config.maxLength ?? undefined;//this.#input.minLength = config.minLength ?? undefined;this.#input.placeHolder = config.placeholder;this.#input.value = config.initialValue ?? '';if (config.onChange) {this.#input.addEventListener('change', (evt) => {config.onChange(this.#input.value);});}this.#lastValidInput = this.#input.value;const constraintFunction = this.#getConstraintFunction(config.constrain);if (constraintFunction) {this.#input.value = constraintFunction(this.#input.value);this.#lastValidInput = this.#input.value;this.#input.addEventListener('input', (evt) => {this.#input.value = constraintFunction(this.#lastValidInput, this.#input.value);this.#lastValidInput = this.#input.value;});}this._appendControlElement(this.#input);}constrainToRegex(regex, lastValidInput, currentInput) {console.debug(`Test ${currentInput}. Last valid = ${lastValidInput}`);return regex.test(currentInput) ? currentInput : lastValidInput;}#getConstraintFunction(constrain) {if (constrain instanceof RegExp) {return (lastValid, current) => this.constrainToRegex(constrain, lastValid, current);} else if (typeof constrain === 'string') {switch (constrain.toUpperCase()) {case 'FLOAT':return (lastValid, current) => this.constrainToRegex(/^[+-]?\d*[.]?\d*$/, lastValid, current);case '+FLOAT':return (lastValid, current) => this.constrainToRegex(/^[+]?\d*[.]?\d*$/, lastValid, current);case 'INT':return (lastValid, current) => this.constrainToRegex(/^[+-]?\d*$/, lastValid, current);case '+INT':return (lastValid, current) => this.constrainToRegex(/^[+]?\d*$/, lastValid, current);default:console.error(`Invalid constraint function ${constraintValue} ignored.`);return;}}return constrain;}getValue() {return this.#input.value;}}export class SpinnerControl extends BaseControl {#step;#minValue;#maxValue;#value;#valueElement;#downButton;#upButton;#onChange;#format;constructor(config) {super('hcje-spinner-control', config);this.#step = config.step || 1;this.#minValue = config.minValue ?? 0;this.#maxValue = config.maxValue ?? 100;this.#value = 0;this.#onChange = config.onChange;this.#format = config.format;const innerContainer = document.createElement('div');innerContainer.className ='hcje-spinner-control__inner ';this.#downButton = new Button({parentElement: innerContainer,url: config.downImage,label: config.downLabel ?? '-',className: 'hcje-spinner-control__inner__down-button',onClick: () => this.#setValueAndNotify(this.#value - this.#step)})this.#valueElement = createChild(innerContainer, 'div', 'hcje-spinner-control__inner__value');this.#upButton = new Button({parentElement: innerContainer,url: config.upImage,label: config.upLabel ?? '+',className: 'hcje-spinner-control__inner__up-button',onClick: () => this.#setValueAndNotify(this.#value + this.#step)});this.#setValue(config.initialValue ?? 0);this._appendControlElement(innerContainer);}#setValue(newValue) {this.#value = utils.clamp(newValue, this.#minValue, this.#maxValue);this.#downButton.disabled = this.#value <= this.#minValue;this.#upButton.disabled = this.#value >= this.#maxValue;this.#valueElement.innerText = this.#format ? this.#format(this.#value) : `${this.#value}`;}#setValueAndNotify(newValue) {this.#setValue(newValue);this.#onChange?.(newValue);}getValue() {return this.#value;}}export class MenuBar {#menuBar;#opener;#closer;onOpen;onClose;constructor(config) {this.#menuBar = document.createElement('div');this.#menuBar.className = 'hcje-menu-bar';this.onOpen = config.onOpen;this.onClose = config.onClose;this.#opener = config.opener;this.#closer = config.close;const parentElement = config.parentElement || document.body;parentElement.appendChild(this.#menuBar);if (this.#opener) {if (this.#opener instanceof ElementWrapper) {this.#opener.appendTo(parentElement);} else {parentElement.appendChild(this.#opener);}this.#opener.classList.add('hcje-menu-opener');this.#opener.classList.add('hcje-menu-opener--visible');this.#opener.addEventListener('click', () => {this.#setMenuOpen(true);this.onOpen?.();});this.#opener}if (this.#closer) {if (this.#closer instanceof ElementWrapper) {this.#closer.appendTo(this.#menuBar);} else {this.#menuBar.appendChild(this.#closer);}this.#closer.addEventListener('click', () => {this.#setMenuOpen(false);this.onClose?.();});}for (const child of config.children) {if (child instanceof ElementWrapper) {child.appendTo(this.#menuBar);} else {this.#menuBar.appendChild(child);}}this.#setMenuOpen(false);}#setMenuOpen(open) {this.#opener.classList.remove(`hcje-menu-opener--${open ? 'visible' : 'hidden'}`);this.#opener.classList.add(`hcje-menu-opener--${!open ? 'visible' : 'hidden'}`);this.#menuBar.classList.remove(`hcje-menu-bar--${!open ? 'visible' : 'hidden'}`);this.#menuBar.classList.add(`hcje-menu-bar--${open ? 'visible' : 'hidden'}`);}close() {this.#setMenuOpen(false);this.onClose?.();}setEnabledState(enabled) {const openers = document.getElementsByClassName('hcje-menu-opener');for (const opener of openers) {opener.disabled = !enabled;}const allInputs = document.querySelectorAll(`hcje-menu-opener input`);allInputs.forEach((input) => input.disabled = !enabled);if (!enabled) {this.#setMenuOpen(false);}}enable() {this.setEnabledState(true);}disable() {this.setEnabledState(false);}remove() {this.#menuBar.remove();}}export function createDialog(config) {const DIALOG_CLASS_NAME = 'hcje-dialog-box';const BASE_Z_INDEX = 1000;const existingDialogs = document.querySelectorAll(`.${DIALOG_CLASS_NAME}`).length;console.debug(`Creating dialog on top of ${existingDialogs} existing dialogs.`);const mask = document.createElement('div');mask.className = 'hcje-dialog-mask hcje-fullscreen';const box = document.createElement('div');box.className = DIALOG_CLASS_NAME;if (config.className) {box.classList.add(config.className);}const header = createChild(box, 'div', 'hcje-dialog-box__title')createChild(header,'h1').innerText = config.title;const dialogBody = createChild(box, 'div', 'hcje-dialog-box__body');if (config.markdown) {dialogBody.innerHTML = parseMarkdown(config.markdown);} else if (config.text) {dialogBody.innerText = config.text;}if (config.children) {for (const child of config.children) {if (child instanceof ElementWrapper) {child.appendTo(dialogBody);} else {dialogBody.appendChild(child);}}}const buttonBar = createChild(box, 'div', 'hcje-dialog-box__buttons');document.body.appendChild(mask);document.body.appendChild(box);const promises = [];for (const defn of config.buttonDefns) {const button = new Button({parentElement: buttonBar,url: defn.url,label: defn.label ?? defn.id,className: 'hcje-dialog-box__button'});promises.push(new Promise((resolve) => {button.addEventListener('click', () => {mask.style.opacity = 0;box.style.opacity = 0;setTimeout(() => {mask.remove();box.remove();resolve(defn.id);}, 500);}, {once: true})}));if (promises.length === 1) {button.focus();}}mask.style.zIndex = BASE_Z_INDEX + existingDialogs * 2;box.style.zIndex = BASE_Z_INDEX + existingDialogs * 2 + 1;return Promise.any(promises);}export class GameArea extends ElementWrapper {#width;#height;#fitWithin;#internalContainer;#margin;#maxScale;#atTop;constructor(config) {super('div');if (config.fitWithin) {this.#fitWithin = config.fitWithin;this.#internalContainer = false;} else {this.#fitWithin = createChild(document.body, 'div', 'hcje-game-area-container hcje-fullscreen');this.#internalContainer = true;}this.appendTo(this.#fitWithin);this.className = 'hcje-game-area';console.log(`GameArea element ${this._element}`);this._element.style.width = `${config.width}px`;this._element.style.height = `${config.height}px`;this.#width = config.width;this.#height = config.height;this.#margin = config.margin;this.#maxScale = config.maxScale;this.#atTop = config.atTop;this.#rescale();if (!config.fixedScale) {console.debug(`Add resize event listener to rescale game area on window change.` );addEventListener('resize', () => this.#rescale());}}#rescale() {let scale = device.getScaleToFit(this.#width, this.#height, {element: this.#fitWithin,margin: this.#margin});if (this.#maxScale) {scale = Math.min(this.#maxScale, scale);}if (this.#atTop) {this._element.style.top = `${this.#margin + 0.5 * this.#height * (scale - 1) }px`;this._element.style.transform = `translate(-50%) scale(${scale})`;} else {this._element.style.transform = `translate(-50%, -50%) scale(${scale})`;}console.debug(`Game area size: design [${this.#width}x${this.#height} at scale of ${scale.toFixed(2)};`);}get designBounds() {return {x: 0, y: 0, width: this.#width, height: this.#height};}get designDims() {return {width: this.#width, height: this.#height};}get scaledDims() {return {width: this.#width * scale, height: this.#height * scale};}remove() {super.remove();if (this.#internalContainer) {this.#fitWithin.remove();}}}export class TimeLimitedBusyIndicator {#element;#label;#timeoutS;#timeoutMessage;#timerId;#started;constructor(options) {this.#label = options.label ?? 'Busy';this.#timeoutS = options.timeoutS ?? 15;this.#timeoutMessage = options.timeoutMessage ??'The last action is taking too long. Do you want to wait? If you cancel, the game will reload.';this.#started = false;}#createIndicator() {this.#element = createChild(document.body, 'progress', 'hcje-busy-indicator');this.#element.setAttribute('aria-label', this.#label);}#activateTimeoutHandler() {this.#timerId = setTimeout(() => {console.warn(`Timeout occured. Ask user for next action: ${this.#timeoutMessage}`);if (confirm(this.#timeoutMessage)) {console.debug('User selected to keep waiting.');this.#activateTimeoutHandler();} else {console.debug('User selected to reload.');location.reload();}}, this.#timeoutS * 1000);}start() {if (this.#started) {throw new Error('Attempt made to restart a BusyIndicator');}this.#started = true;this.#createIndicator();if (this.#timeoutS > 0) {this.#activateTimeoutHandler();}}end() {clearTimeout(this.#timerId);this.#element.remove();}}