/* Copyright 2025 Steve Butler (henspace.com)
 * License: MIT
 */
import * as utils from './utils.js';class AudioManager {#audioPlayerFactory;#soundEffects = new Map();#backgroundMusic;context;#decompressor;#gainconstructor() {this.context = new AudioContext();this.#decompressor = this.context.createDynamicsCompressor();this.#decompressor.connect(this.context.destination);this.#gain = new GainNode(this.context);this.#gain.connect(this.#decompressor);this.#audioPlayerFactory = new AudioPlayerFactory();}get inputNode() {return this.#gain;}get gain() {return this.#gain.gain}set gain(value) {this.#gain.gain.setTargetAtTime(value, this.context.currentTime, 0.08);}addAudioSfx(definition) {if (definition.loop) {definition.loop = false;}return this.#audioPlayerFactory.createAudioSfxFromDefinition(definition).then((sfx) => {this.#soundEffects.set(definition.title, sfx);return true;})}playAudioSfx(title) {try {this.#soundEffects.get(title)?.play();} catch (error) {console.error(`Unable to play sound effect ${title}: ${error}`);}}setMusic(definition) {console.debug(`Set music ${definition.title} called.`);if (this.#backgroundMusic) {console.debug('Stop existing music.');this.#backgroundMusic.stop();}this.#backgroundMusic = new MusicPlayer(definition.title, definition.fadeSeconds);this.#backgroundMusic.connect(this.#gain);this.#backgroundMusic.start();return this.#audioPlayerFactory.createPlayerFromDefinition(definition).then((player) => this.#backgroundMusic.setPlayer(player)).then(() => {this.#backgroundMusic.actionCachedCommand();return true;}).catch((error) => {console.error(`Unable to create this.#background music player ${definition.title}: ${error}`);this.#backgroundMusic = undefined;return false;});}stopMusic() {this.#backgroundMusic?.stop();}startMusic() {if (this.#backgroundMusic && !this.#backgroundMusic.isPlaying()) {this.#backgroundMusic?.start();}}}class SequencePlayer {static TC_COMPLETE = 3;#sequence;#position;#lastFrequency;#gainNode;#sourceNode;#attackTc;#decayTc;#releaseTc;#freqTc;#decayStart;#sustainStart;#releaseStart;#sustainLevel;#usesAdsr;#merge;#maxGain;#sweepFactor;constructor(config) {this.#sequence = config.sequence;this.#gainNode = config.gainNode;this.#sourceNode = config.sourceNode;this.#merge = !!config.sequence.instrument.merge;this.#maxGain = config.sequence.instrument.maxGain ?? 1;this.#position = 0;this.#lastFrequency = 0;this.#usesAdsr = !!config.sequence.instrument.adsr;this.#sweepFactor = config.sequence.instrument.sweepFactor ?? 1;if (this.#usesAdsr) {const attack = config.sequence.instrument.adsr[0];const decay = config.sequence.instrument.adsr[1];this.#sustainLevel = config.sequence.instrument.adsr[2]const release = config.sequence.instrument.adsr[3];this.#attackTc = attack / SequencePlayer.TC_COMPLETE;this.#decayTc = decay / SequencePlayer.TC_COMPLETE;this.#releaseTc = release / SequencePlayer.TC_COMPLETE;this.#freqTc = this.#attackTc + this.#decayTc + this.#releaseTc;this.#decayStart = attack;this.#sustainStart = attack + decay;this.#releaseStart = config.sequence.instrument.sustainTime + this.#sustainStart;this.#merge = config.sequence.instrument.allowMerge && this.#releaseStart >= config.interval;}}#applyEnvelope(newFreq) {let start = audioMgr.context.currentTime;this.#gainNode.gain.cancelScheduledValues(start);if (this.#usesAdsr) {if (newFreq !== this.#lastFrequency || !this.#merge) {this.#gainNode.gain.setTargetAtTime(this.#maxGain, start, this.#attackTc);this.#gainNode.gain.setTargetAtTime(this.#sustainLevel * this.#maxGain, start + this.#decayStart, this.#decayTc);}this.#gainNode.gain.setTargetAtTime(0, start + this.#releaseStart, this.#releaseTc);} else {this.#gainNode.gain.setTargetAtTime(this.#maxGain, start, 0.01);}}#applyRest() {if (!this.#usesAdsr) {this.#gainNode.gain.setTargetAtTime(0, audioMgr.context.currentTime, 0.01);}}#applyFreq(newFreq) {if (this.#sourceNode.frequency) {const start = audioMgr.context.currentTime;this.#sourceNode.frequency.cancelScheduledValues(start);this.#sourceNode.frequency.setValueAtTime(newFreq, start);if (this.#sweepFactor !== 1) {this.#sourceNode.frequency.setTargetAtTime(newFreq * this.#sweepFactor, start, this.#freqTc);}}}playNext() {if (!this.#sequence) {console.log(`No sequence for player to play.`);return false;}const newFreq = this.#sequence.freqs[this.#position++];if (newFreq === 0) {this.#applyRest();} else {this.#applyFreq(newFreq);this.#applyEnvelope(newFreq);}this.#lastFrequency = newFreq;if (this.#position >= this.#sequence.freqs.length) {this.#position = 0;return false;} else {return true;}}stop() {this.#position = 0;if (this.#usesAdsr) {setTimeout(() => {this.#sourceNode.stop();}, 1000 * this.#releaseStart + SequencePlayer.TC_COMPLETE * this.#releaseTc);} else {this.#sourceNode.stop();}}}class Synthesiser {#gainNodes;#sequences;#loop;#quaverMs;#stopSignal;#audioSourceFactories;#playing;constructor(sequences, options) {this.#sequences = sequences;this.#quaverMs = options.quaverMs;this.#loop = options.loop ?? false;console.debug(`Synthesiser loop set to ${this.#loop}`);this.#stopSignal = false;this.#audioSourceFactories = [];this.#gainNodes = [];this.#playing = false;for (const sequence of this.#sequences) {const gainNode = new GainNode(audioMgr.context, {gain: 0});this.#gainNodes.push(gainNode);this.#audioSourceFactories.push(this.#createAudioSourceFactory(sequence));}}#playSequencesToCompletion() {const players = [];this.#playing = true;return new Promise((resolve) => {let moreToPlay = this.#loop;for (let n = 0; n < this.#sequences.length; n++) {const sequence = this.#sequences[n];const gainNode = this.#gainNodes[n];const sourceNode = this.#audioSourceFactories[n].createSource();sourceNode.connect(gainNode);sourceNode.start();const player = new SequencePlayer({sequence, gainNode, sourceNode, interval: this.#quaverMs / 1000});players.push(player);moreToPlay = player.playNext() || moreToPlay;}if (!moreToPlay) {this.#stopAllPlayers(players);resolve();return;}let intervalTimer;intervalTimer = setInterval(() => {moreToPlay = this.#loop;for (const player of players) {moreToPlay = player.playNext() || moreToPlay;}if (!moreToPlay || this.#stopSignal) {clearInterval(intervalTimer);this.#stopAllPlayers(players);resolve();}}, this.#quaverMs);});}#stopAllPlayers(players) {for (const player of players) {player.stop();}this.#playing = false;}isReady() {return true;}isPlaying() {return this.#playing;}connect(destination) {for (const gainNode of this.#gainNodes) {gainNode.connect(destination);}}play() {if (this.#loop) {console.warn('Attempt to play looping sound as sound effect ignored.');return;}this.start();}start() {this.#stopSignal = false;if (!this.#loop || !this.#playing) {this.#playSequencesToCompletion();}}stop() {this.#stopSignal = true;}#createAudioSourceFactory(sequence) {switch (sequence.instrument.waveform) {case 'noise':return new WhiteNoiseFactory(1, {frequency: 440,detune: sequence.detune,type: 'bandpass'});default:return new OscillatorNodeFactory({frequency: 440,detune: sequence.detune,type: sequence.instrument.waveform || 'sine'});}}}class OscillatorNodeFactory {#options;constructor(options) {this.#options = options;}createSource() {return new OscillatorNode(audioMgr.context, this.#options);}}class WhiteNoiseSource extends BiquadFilterNode {#source;constructor(source, options) {super(audioMgr.context, options);this.#source = source;// const filter = new BiquadFilterNode(audioMgr.context, options);this.#source.connect(this);}start(when) {this.#source.start(when);}stop(when) {this.#source.stop(when);}}class WhiteNoiseFactory {#buffer;#options;constructor(duration, options) {this.#options = options;this.#buffer = audioMgr.context.createBuffer(1, audioMgr.context.sampleRate * duration, audioMgr.context.sampleRate);const channelData = this.#buffer.getChannelData(0);for (let n = 0; n < this.#buffer.length; n++) {channelData[n] = 2 * Math.random() - 1;}}createSource() {const source = audioMgr.context.createBufferSource();source.buffer = this.#buffer;source.loop = true;return new WhiteNoiseSource(source, this.#options);}}class AudioPlayerFactory {#frequencyTables;#majorTriads = new Map([['A', ['C#', 'E']],['A#', ['D', 'F']],['Bb', ['D', 'F']],['B', ['D#', 'F#']],['C', ['E', 'G']],['C#', ['E#', 'G#']],['Db', ['F', 'Ab']],['D', ['F#', 'A']],['D#', ['G', 'A#']],['Eb', ['G', 'Bb']],['E', ['G#', 'B']],['F', ['A', 'C']],['F#', ['A#', 'C#']],['Gb', ['Bb', 'Db']],['G', ['B', 'D']],['G#', ['B#', 'D#']],['Ab', ['C', 'Eb']],]);#minorTriads = new Map([['A', ['C', 'E']],['A#', ['C#', 'E#']],['Bb', ['Db', 'F']],['B', ['D', 'F#']],['C', ['Eb', 'G']],['C#', ['E', 'G#']],['Db', ['Fb', 'Ab']],['D', ['F', 'A']],['D#', ['F#', 'A#']],['Eb', ['Gb', 'Bb']],['E', ['G', 'B']],['F', ['Ab', 'C']],['F#', ['A', 'C#']],['Gb', ['A', 'Db']],['G', ['Bb', 'D']],['G#', ['B', 'D#']],['Ab', ['Cb', 'Eb']],]);#buildFrequencyTables() {if (this.#frequencyTables) {return;}const minOctave = 0;const maxOctave = 7;const baseNote = 'A';const baseOctave = 4const baseFreq = 440;const OCTAVE_NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];const indexOfBaseNote = OCTAVE_NOTES.indexOf(baseNote);const octaveFreqs = [];for (let octave = minOctave; octave <= maxOctave; octave++) {const frequencies = new Map();for (let index = 0; index < OCTAVE_NOTES.length; index++) {const semitonesFromBase = (octave - baseOctave) * OCTAVE_NOTES.length   - indexOfBaseNote + index;const freq = baseFreq * Math.pow(2, semitonesFromBase/12);frequencies.set(OCTAVE_NOTES[index], freq);}// add flat aliases for sharps and flats which are already in octave under a different note.frequencies.set('Cb', frequencies.get('B'));frequencies.set('Db', frequencies.get('C#'));frequencies.set('Eb', frequencies.get('D#'));frequencies.set('E#', frequencies.get('F'));frequencies.set('Fb', frequencies.get('E'));frequencies.set('Gb', frequencies.get('F#'));frequencies.set('Ab', frequencies.get('G#'));frequencies.set('Bb', frequencies.get('A#'));frequencies.set('B#', frequencies.get('C'));octaveFreqs.push(frequencies);}return this.#frequencyTables = octaveFreqs;}logFrequencyTables() {for (const octave of this.#frequencyTables) {let notes = '';for (const entry of octave.entries()) {notes = `${notes}${entry[0]}: ${entry[1]}, `;}console.log(notes);}}#decodeTrack(track) {if (!track?.notes || track.notes.length === 0) {console.error(`No notes provided.`);return;}this.#buildFrequencyTables();const trackOctave = track.octave ?? 4;let detune = track.detune ?? 0;const noteDefns = [...track.notes.matchAll(/(\+*|-*)?([ABCDEFG~](?:[#b])?)(\d)?(\.)?([@$])?/gm)];const freqData = [];for (const noteDefn of noteDefns) {let octave = trackOctave;const octaveModifier = noteDefn[1] ?? '';if (octaveModifier.startsWith('+')) {octave = utils.clamp(trackOctave + octaveModifier.length, 0, this.#frequencyTables.length - 1);} else if (octaveModifier.startsWith('-')) {octave = utils.clamp(trackOctave - octaveModifier.length, 0, this.#frequencyTables.length - 1);}const note = noteDefn[2];const noteFraction = noteDefn[3] ?? 4; // default to quarter noteconst dotted = !!noteDefn[4];const arpeggio = !!noteDefn[5];let triads;if (arpeggio) {triads = noteDefn[5] === '@' ? this.#majorTriads : this.#minorTriads;}let quavers = 8 / noteFraction;if (dotted) {quavers *= 1.5;}quavers = Math.floor(quavers);const freq = note === '~' ? 0 : this.#frequencyTables[octave].get(note);if (freq === undefined) {console.error(`Illegal note ${note} converted to rest.`);freq = 0;}for (let q = 0; q < quavers; q++) {if (q === 0) {freqData.push(freq);} else if (arpeggio && freq !== 0 && q < 3) {const chordNote = triads.get(note)[q - 1];const chordFreq = this.#frequencyTables[octave].get(chordNote);if (!chordFreq) {console.warn(`Illegal chord note ${chordNote} for note ${note} converted to rest.`);chordFreq = 0;}freqData.push(chordFreq);} else {freqData.push(0);}}}return freqData.length > 0 ? {detune, instrument: track.instrument, freqs: freqData} : null;}#createSynthesiser(definition) {if (!definition) {throw new Error ('Cannot create dynamic sound as no definition provided.');}const quaverMs = Math.round(60000 / (definition.bpm * 2));const decodedTracks = [];for (let index = 0; index < definition.tracks.length; index++) {const track = definition.tracks[index];let decodedTrack;if (index > 0 && track.notes === '=') {console.debug(`Track ${index} is copy of previous detuned by ${track.detune} cents.`);decodedTrack = {detune: track.detune,freqs: decodedTracks[index - 1].freqs,instrument: decodedTracks[index - 1].instrument}} else if (track.notes) {decodedTrack = this.#decodeTrack(track);}if (decodedTrack) {decodedTracks.push(decodedTrack);}}return new Synthesiser(decodedTracks, {quaverMs, loop: definition.loop});}createPlayerFromDefinition(definition) {if (definition.tracks) {return Promise.resolve(this.#createSynthesiser(definition));} else {return MediaFilePlayer.createFromDefinition(definition);}}createAudioSfxFromDefinition(definition) {if (definition.tracks) {if (definition.loop) {throw new Error(`Sound effects cannot loop. Check the definition.`);}return Promise.resolve(this.#createSynthesiser(definition)).then((sfx) => {sfx.connect(audioMgr.inputNode);return sfx;});} else {return MediaFileSfx.createFromDefinition(definition);}}}class MediaFileSfx {#audioElement;constructor(url) {this.#audioElement = new Audio(url);}play() {this.#audioElement.play();}static createFromDefinition(definition) {const sfx = new MediaFileSfx(definition.url);return new Promise((resolve) => {sfx.#audioElement.addEventListener('canplaythrough',(event) => resolve(sfx), {once:true});});}}class MediaFilePlayer {#destination;#buffer;#loop;#source;#ready;#playing;constructor(options) {this.#ready = false;this.#playing = false;this.#loop = !!options.loop;}static createFromDefinition(definition) {const audioPlayer= new MediaFilePlayer({loop: !!definition.loop});return utils.fetchArrayBuffer(definition.url).then((arrayBuffer) => audioPlayer.#setBufferFromData(arrayBuffer)).then(() => audioPlayer);}#setBufferFromData(data) {this.#ready = false;this.#buffer = undefined;return audioMgr.context.decodeAudioData(data).then((buffer) => {this.#buffer = buffer;this.#ready = true;}).catch((error) => {console.error(`Unable to decode audio data: ${error}`);return;});}isReady() {return this.#ready;}isPlaying() {return this.#playing;}connect(destination) {this.#destination = destination;}start() {if (!this.#buffer) {console.warn(`Attempt to start sound when no buffer available to play.`);return;}if (this.#playing) {console.warn(`Attempt to start sound while already started ignored.`);return;}try {this.#source = new AudioBufferSourceNode(audioMgr.context, {buffer: this.#buffer,loop: this.#loop})this.#source.connect(this.#destination);this.#source.start();this.#playing = true;} catch (error) {console.error(`Unable to start audio: ${error}`);}}stop() {if (!this.#playing) {console.warn(`Attempt to stop audio when not playing ignored.`);return;}this.#source.stop(audioMgr.context.currentTime);this.#playing = false;}}class MusicPlayer {static MusicCommand = {NONE: 0,START: 1,STOP: 2};#title;#gainNode;#audioPlayer;#fadeSeconds;#cachedCommand = MusicPlayer.MusicCommand.NONE;#playingWhenFocusLost;constructor(title, fadeSeconds = 1) {this.#title = title;this.#gainNode = audioMgr.context.createGain();this.#fadeSeconds = fadeSeconds;window.addEventListener('blur', () => {if (this.isPlaying()) {console.debug(`Lost focus so stop ${this.#title}`)this.#playingWhenFocusLost = true;this.stop();} else {this.#playingWhenFocusLost = false;}});window.addEventListener('focus', () => {if (this.#playingWhenFocusLost) {console.debug(`Was playing when focus originally lost, so resume ${this.#title}`)this.start();}});}setPlayer(audioPlayer) {if (this.#audioPlayer) {throw new Error(`Only one player permitted for ${this.#title}`);}this.#audioPlayer = audioPlayer;audioPlayer.connect(this.#gainNode);}#setGain(value) {if (this.#gainNode) {this.#gainNode.gain.setValueAtTime(value, audioMgr.context.currentTime);}}#fadeIn() {if (this.#fadeSeconds <= 0 || !this.#gainNode) {return;}try {this.#setGain(0);this.#gainNode.gain.setTargetAtTime(1.0, audioMgr.context.currentTime, this.#fadeSeconds / 3);} catch (error) {console.error(`Unable to fade in music ${this.#title}: ${error}`);}}#fadeOut() {if (this.#fadeSeconds <= 0 || !this.#gainNode) {return;}try {this.#gainNode.gain.setTargetAtTime(0.0, audioMgr.context.currentTime, this.#fadeSeconds / 3);} catch (error) {console.error(`Unable to fade out music ${this.#title}: ${error}`);}}start() {if (!this.#audioPlayer?.isReady()) {console.debug(`Music ${this.#title} not ready so cache start.`);this.#cachedCommand = MusicPlayer.MusicCommand.START;return;}console.debug(`Start music ${this.#title}.`);this.#cachedCommand = MusicPlayer.MusicCommand.NONE;try {if (this.#fadeSeconds) {this.#fadeIn();}this.#audioPlayer.start();} catch (error) {console.error(`Unable to start music ${this.#title}: ${error}`);}}stop() {if (!this.#audioPlayer.isReady()) {console.debug(`Audio buffer for music ${this.#title} not ready so STOP command cached.`);this.#cachedCommand = MusicPlayer.MusicCommand.STOP;return;}console.debug(`Stop music ${this.#title}.`);this.#fadeOut();setTimeout(() => {this.#audioPlayer.stop(this.#fadeSeconds);}, this.#fadeSeconds * 1000);}actionCachedCommand() {if (!this.#audioPlayer.isReady()) {console.debug('Attempt to action cached command before track is ready ignored.');} else if (this.#cachedCommand === MusicPlayer.MusicCommand.START) {this.start();}this.#cachedCommand = MusicPlayer.MusicCommand.NONE;}isPlaying() {return this.#audioPlayer?.isPlaying();}isReady() {return this.#audioPlayer?.isReady();}connect(destination) {this.#gainNode.connect(destination);}}export const Instrument = {CYMBAL: {adsr: [0.01, 0.01, 0.3, 0.3],allowMerge: false,maxGain: 0.2,sustainTime: 0.05,sweepFactor: 2,waveform: 'noise',},DRUM: {adsr: [0.01, 0.05, 0.1, 0.2],allowMerge: false,maxGain: 1,sustainTime: 0.1,sweepFactor: 0.8,waveform: 'sine',},PIANO: {adsr: [0.01, 0.25, 0.1, 0.1],allowMerge: false,maxGain: 1,sustainTime: 0.1,sweepFactor: 1,waveform: 'sine',},SNARE: {adsr: [0.01, 0.01, 0.1, 0.01],allowMerge: false,maxGain: 0.5,sustainTime: 0.05,sweepFactor: 1,waveform: 'noise',}};let audioMgr = new AudioManager();export function getAudioManager() {if (!audioMgr) {audioMgr = new AudioManager();}return audioMgr;}