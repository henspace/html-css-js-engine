<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: build/build.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/custom-theme.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: build/build.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * MIT license
 * Copyright © 2025 Steve Butler (henspace.com)
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the “Software”),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/**
 * @module hcjeTools/build/build
 * @description
 * Script for building the source and intended to be run under Node.js.
 * The size of the resulting script is reduced by removing comments and leading and
 * trailing spaces.
 *
 * Usage:
 * + build configFile
 *     + configFile: the configuration file; see below.
 *
 * ## Configuration file
 * The script should be passed the path to a configuration file as the only command line argument.
 * This is used to control the output. The configuration file is a JSON representation of a
 * [ConfigurationOptions]{@link module:hcjeTools/build/build~ConfigurationOptions} object.
 *
 * ## Template strings
 *
 * When html, js, or md files are processed, the following template strings are replaced. They are all case-sensitive.
 *
 * +  **%%\_AUTHOR\_%%** replaced by **author** field  from package.json
 * +  **%%\_BUILD\_DATE\_ISO\_%%** replaced by date of the build in ISO format.
 * +  **%%\_BUILD\_YEAR\_%%** replaced by year of the build.
 * +  **%%\_BUILD\_ID\_%%** replaced by a short code based on the date and time of the build.
 * +  **%%\_DESCRIPTION\_%%** replaced by the **description** field from package.json.
 * +  **%%\_LICENCE\_%%** or %%\_LICENSE\_%% replaced by the **license** field from package.json.
 * +  **%%\_NAME\_%%** replaced by the **name** field from package.json
 * +  **%%\_VERSION\_%%** replaced by the **version** field from package.json.
 **/

/** 
 * Configuration object.
 * @typedef {Object} ConfigurationOptions
 * @property {string} outputDir - Path to where the resulting files will be copied. Only ./build or ./docs are permitted.
 * @property {string} subDir - If provided, the build will be placed in **outputDir/subDir**.
 * @property {string} zippedOutputDir - Path to where a zipped copy of the build output will be placed.
 *   This will include the version from package.json in the file name. Note, if a subdir is provided, this will
 *   contain the contents of **outputDir/subDir** not **outputDir**.
 * @property {string} readme - Path to a readme file that is written to the **outputDir**. This is written pre-build,
 *   so if the source folder (root) also contains a readme file, and the **subDir** option is not set, the readme
 *   will be overwritten.
 * @property {string} root - Path to the source folder containing the files to copy to the **outputDir**.
 *
 * @property {Object} filter - Detail of filters to restrict the files copied to the output.
 * @property {Object} filter.includeFiles - Regular expression detail. Only file names matching the regular expression 
 *   are included. The regular expression is created as `new RegExp(regex, flags)`.
 * @property {string} filter.includeFiles.regex - The string that forms the regular expression.
 * @property {string} filter.includeFiles.flags - Any flags to use with the regular expression.
 * 
 * @property {Object} filter.excludeFiles - Regular expression detail. Any file names matching the regular expression are excluded.
 * @property {string} filter.excludeFiles.regex - The string that forms the regular expression.
 * @property {string} filter.excludeFiles.flags - Any flags to use with the regular expression.
 *  
 * @property {Object} filter.excludeDirs - Regular expression detail. Any directory names matching the regular expression are excluded.
 * @property {string} filter.excludeDirs.regex - The string that forms the regular expression.
 * @property {string} filter.excludeDirs.flags - Any flags to use with the regular expression.
 *
 * @property {Object} parserConfig - Additional detail added to the output for specific file types:
 * @property {Object} parserConfig.html - Additional text for html files:
 * @property {string} parserConfig.html.prefix - Text added at the beginning of the output.
 * @property {string} parserConfig.html.suffix - Text added at the end of the output.
 *
 * @property {Object} parserConfig.js - Additional text for JavaScript files:
 * @property {string} parserConfig.js.prefix - Text added at the beginning of the output.
 * @property {string} parserConfig.js.suffix - Text added at the end of the output.
 *
 * @property {Object} parserConfig.md - Additional text for Markdown files:
 * @property {string} parserConfig.md.prefix - Text added at the beginning of the output.
 * @property {string} parserConfig.md.suffix - Text added at the end of the output.
 *
 * @property {string} zipCommand - Command to run to create the zip file. The text **${zipOutputDir}** and 
 *   **${zipSourceDir}** are replaced by the path to where the zip file should be written and the path to the files 
 *  that should be zipped.
 */

import * as fsPromises from 'node:fs/promises';
import { existsSync, mkdirSync } from 'node:fs';
import * as path from 'node:path';
import { exec } from 'node:child_process';

/**
 * Show usage.
 * @param {string} message
 * @private
 */
function showUsageAndExit(message) {
  console.error(message);
  console.error('\nUsage: build configFile');
  process.exit(1);
}

/** 
 * Replace template variables with information from package details.
 * Template variables begin are enclosed between %%_ and _%% characters.
 * @param {string} data - the string to process
 * @param {Object} packageDetails - details from package.json
 * @returns {string} data with template variables replaced.
 * @private
 */
function replaceTemplateVariables(data) {
  const date = new Date();
  data = data.replace(/%%_AUTHOR_%%/g, packageDetails.author);
  data = data.replace(/%%_BUILD_DATE_ISO_%%/g, date.toISOString().substring(0, 10));
  data = data.replace(/%%_BUILD_YEAR_%%/g, date.getFullYear());
  data = data.replace(/%%_BUILD_ID_%%/g, date.valueOf().toString(36));
  data = data.replace(/%%_DESCRIPTION_%%/g, packageDetails.description);
  data = data.replace(/%%_LICEN[CS]E_%%/g, packageDetails.license);
  data = data.replace(/%%_NAME_%%/g, packageDetails.name);
  data = data.replace(/%%_VERSION_%%/g, packageDetails.version);
  return data;
}

/**
 * Reduce size of js file.
 * @param {string} data - data to parse 
 * @param {string} prefix - added to start of content
 * @param {Object} packageDetails - details from package.json
 * @returns {string}
 * @private
 */ 
function parseJs(data, prefix, packageDetails) {
    data = data.replace(/(?:^|[\r\n\t]) *\/\*.*?\*\//gs, '');
    data = data.replace(/^\s+/gm, '');
    data = data.replace(/\s+$/gm, '');
    data = prefix + data;
    return replaceTemplateVariables(data, packageDetails);
}

/**
 * Parse markdown file replacing template variables.
 * @param {string} data - data to parse 
 * @param {string} prefix - added to start of content
 * @param {Object} packageDetails - details from package.json
 * @returns {string}
 * @private
 */ 
function parseMarkdown(data, prefix, packageDetails) {
    data = prefix + data;
    return replaceTemplateVariables(data, packageDetails);
}

/**
 * Parse html file replacing template variables.
 * @param {string} data - data to parse 
 * @param {string} prefix - added to start of content
 * @param {Object} packageDetails - details from package.json
 * @returns {string}
 * @private
 */ 
function parseHtml(data, prefix, packageDetails) {
    data = prefix + data;
    return replaceTemplateVariables(data, packageDetails);
}


/**
 * Copy file through a parser.
 * @param {string} filePath - file to copy
 * @param {string} destFile - destination file
 * @param {Object} options
 * @param {function} options.parser - function that will parse the file
 * @param {Object} options.config - configuration options for parser
 * @param {Object} options.packageDetails - details from package.json
 * @returns {Promise}
 * @private
 */
function copyAndParse(filePath, destFile, options) {
  return fsPromises.readFile(filePath, {encoding: 'utf-8'})
    .then((contents) => {
      contents = options.parser(contents, options.config.prefix,
        options.packageDetails) ;
      return contents;  
    })
   .then((data) => {
      return fsPromises.writeFile(destFile, data, {
          encoding: 'utf-8', 
          flush: true,
      });
   })

}
/**
 * Copy file to output directory.
 * @param {string} filePath - path to file
 * @param {string} targetDir - target directory
 * @param {Object} options
 * @param {Object} options.parserConfig - options for parsers
 * @param {Object} options.packageDetails - node package information
 * @returns {Promise}
 * @private
 */
function copyFile(filePath, targetDir, options) {
  console.log(`Copy file ${filePath} to ${targetDir}`);
  const destination = path.join(targetDir, path.basename(filePath));
  const extension = path.extname(filePath).toLowerCase();
  let parserOptions;
  switch (extension) {
    case '.html': parserOptions = {
        parser: parseHtml,
        config: options.parserConfig.html,
        packageDetails: options.packageDetails
      };
      break;
    case '.js': parserOptions = {
        parser: parseJs,
        config: options.parserConfig.js,
        packageDetails: options.packageDetails
      };
      break;
    case '.md': parserOptions = {
        parser: parseMarkdown,
        config: options.parserConfig.md,
        packageDetails: options.packageDetails
      };
      break;

  }
  if (parserOptions) {
    return copyAndParse(filePath, destination, parserOptions);
  } else {
    return fsPromises.copyFile(filePath, destination);
  }
}

/**
 * Remove directory. It's contents are removed but the directory will remain.
 * @param {*} path - path to directory to remove.
 * @returns Promise which fulfils to undefined on success.
 * @private
 */
function removeDir(path) {
  return fsPromises.rm(path, { force: true, recursive: true });
}

/**
 * Copy directory to output directory. The name of the source 
 * directory is added to the target so that the original structure is 
 * maintained. If the directory does not exist, it's created.
 * @param {string} sourceDir - source directory
 * @param {string} targetDir - target directory
 * @param {Object} options
 * @param {RegExp} options.includeFiles - Filter for file names. Only these are included.
 * @param {RegExp} options.excludeFiles - Filter for file names. These are excluded.
 * @param {RegExp} options.excludeDirs - Filter for directories that are excluded.
 * @param {Object} options.parserConfig - Options for parsers.
 * @param {Object} options.packageDetails - Node package information
 * @returns {Promise}
 * @private
 */
async function copyDirectory(sourceDir, targetDir, options) {
  console.log(`Copy directory ${sourceDir} to ${targetDir}`);
  const exists = await existsSync(targetDir);
  if (!exists) {
    console.log(`Create ${targetDir}`);
    await mkdirSync(targetDir, {recursive: true});
  }
  return fsPromises.readdir(sourceDir, {
      encoding: 'utf-8',
      withFileTypes: true,
      recursive: false
    })
    .then((result) => {
      const promises = [];
      for (const dirent of result) {
        const direntPath = path.join(sourceDir, dirent.name);
        if (dirent.isFile()) {
          if (options.includeFiles?.test(dirent.name) &amp;&amp; !options.excludeFiles?.test(dirent.name)) {
            promises.push(copyFile(direntPath, targetDir, options));
          } else {
            console.log(`Ignore ${dirent.name}`);
          }
        } else if (dirent.isDirectory()) {
          if (options.excludeDirs?.test(dirent.name)) {
            console.log(`Ignore directory ${dirent.name}`);
          } else {
            const destinationDir = path.join(targetDir, dirent.name);
            promises.push(copyDirectory(direntPath, destinationDir, options));
          }
        }
      }
      return Promise.all(promises);
    }) 
}


/**
 * Compress folder. 
 * The zip command is executed. The ${zipSourceDir} and ${zipOutputDir} parameters are replaced by the sourceDir and
 * outputDir parameters.
 * @param {string} zipCommand - command to execute to create the zip file
 * @param {string} sourceDir - path to the files to zip.
 * @param {string} outputDir - path to the location where the zip files should be placed.
 * @returns {Promise}
 * @private
 */
function compressFolder(zipCommand, sourceDir, outputDir) {
  let cmd = zipCommand.replace(/\${zipSourceDir}/g, sourceDir);
  cmd = cmd.replace(/\${zipOutputDir}/g, outputDir);
  console.log(`Zip command: ${cmd}`);

  return new Promise((resolve) => exec(cmd, {encoding: 'utf-8'}, (err, stdout, stderr) => {
    if (err) {
      console.error(`Failed to compress ${sourceDir}: ${err.message}`);
    } else {
      console.log(stdout);
    }
    resolve();
  })); 
}

/**
 * Details of the package. This will be taken from package.json
 * @type {Object}
 * @private
 */
let packageDetails;


// Execute build
if (process.argv.length &lt; 3) {
  showUsageAndExit('Incorrect arguments.');
} 

let configFile = process.argv[2];
console.log(`Loading options from ${configFile}`);
let options;
let buildOutputDir;

fsPromises.readFile('package.json', {encoding: 'utf-8'})
  .then((json) => {
    packageDetails = JSON.parse(json);
  })
  .then(() => fsPromises.readFile(configFile, {encoding: 'utf-8'}))
  .then((json) => {
    options = JSON.parse(json);
    buildOutputDir = options.outputDir;
    if (options.subDir) {
      buildOutputDir = path.join(buildOutputDir, options.subDir);
    }
  })
  .then(() => {
    if (!/^\.\/(?:build|docs)$/.test(options.outputDir)) {
      throw new Error(`Only ./build or ./docs supported as build directories. Will not delete or build to ${options.outputDir}.`);
    }
    return removeDir(options.outputDir);
  })
  .then(() => fsPromises.mkdir(buildOutputDir, {recursive: true}))
  .then(() => fsPromises.mkdir(options.zippedOutputDir, {recursive: true}))
  .then(() => {
    if (options.readme) {
      return copyFile(options.readme, options.outputDir, {
          parserConfig: options.parserConfig,
          packageDetails: packageDetails
      })
    }
  })
  .then(() => {
    let includeFilesRegex;
    let excludeFilesRegex;
    let excludeDirsRegex;
    if (options.filter?.includeFiles) {
      includeFilesRegex = new RegExp(options.filter.includeFiles.regex, options.filter.includeFiles.flags);
    }
    if (options.filter?.excludeFiles) {
      excludeFilesRegex = new RegExp(options.filter.excludeFiles.regex, options.filter.excludeFiles.flags);
    }
    if (options.filter?.excludeDirs) {
      excludeDirsRegex = new RegExp(options.filter.excludeDirs.regex, options.filter.excludeDirs.flags);
    }
    return copyDirectory(options.root, buildOutputDir, {
        includeFiles: includeFilesRegex,
        excludeFiles: excludeFilesRegex,
        excludeDirs: excludeDirsRegex,
        parserConfig: options.parserConfig,
        packageDetails: packageDetails
      })
  })
  .then(() => {
    const zipName = (`${packageDetails.name}_${packageDetails.version}`
        .replace(/[.]/g, '_')).toLowerCase();
    return compressFolder(options.zipCommand, options.outputDir, path.join(options.zippedOutputDir, zipName));
  })
  .then(() => {
    console.log(`Build complete.`); 
  });


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-hcjeTools_build_build.html">hcjeTools/build/build</a></li><li><a href="module-hcjeTools_server_requestListener.html">hcjeTools/server/requestListener</a></li><li><a href="module-hcjeTools_server_server.html">hcjeTools/server/server</a></li><li><a href="module-hcjeTools_testing_runner.html">hcjeTools/testing/runner</a></li><li><a href="module-hcjeTools_testing_utils.html">hcjeTools/testing/utils</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Dec 08 2025 11:30:40 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
